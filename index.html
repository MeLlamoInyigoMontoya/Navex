<!DOCTYPE html>
<html lang="es">

<head>
	<meta charset="UTF-8" />
	<title>NÁVEX v.1.0 (Beta)</title>
	<script src="https://cdn.tailwindcss.com"></script>

	<style>
		/* ===== Estilos globales ===== */
		body {
			margin: 0;
			background-color: #1a1a1a;
			font-family: sans-serif;
			overflow: hidden;
			display: flex;
			justify-content: center;
			align-items: center;
			height: 100vh;
		}

		#gameContainer {
			position: relative;
			width: 100%;
			max-width: 800px;
			height: 100vh;
			background-color: black;
			box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
			overflow: hidden;
		}

		canvas {
			display: block;
			position: relative;
			z-index: 1;
		}

		/* ===== HUD ===== */
		#hud {
			position: absolute;
			top: 10px;
			left: 0;
			right: 0;
			z-index: 10;
			color: white;
			padding: 0 20px;
		}

		.row1 {
			display: flex;
			justify-content: space-between;
			align-items: flex-end;
			height: 40px;
		}

		#lives {
			display: flex;
			align-items: flex-end;
		}

		.heart {
			font-size: 24px;
			margin-right: 4px;
		}

		.heart.empty {
			opacity: 0.3;
		}

		#score {
			font-size: 26px;
			color: gold;
			line-height: 1;
		}

		#levelIndicator {
			font-size: 16px;
			color: #aaa;
			margin-top: 2px;
		}

		.row2 {
			display: flex;
			justify-content: space-between;
			align-items: center;
			margin-top: 4px;
			font-size: 16px;
			padding: 0 20px;
			color: #ccc;
		}

		.hud-right {
			display: flex;
			align-items: center;
			gap: 12px;
		}


		/* ===== Overlay de nivel ===== */
		#levelOverlay {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: radial-gradient(circle at center,
					rgba(0, 0, 0, 0.9),
					rgba(0, 0, 0, 1));
			display: none;
			z-index: 20;
			flex-direction: column;
			justify-content: center;
			align-items: center;
			text-align: center;
			padding: 20px;
		}

		#levelOverlay h1 {
			font-size: 48px;
			color: #ff0;
			text-shadow: 2px 2px 8px #000;
			margin: 0;
		}

		#levelOverlay p {
			font-size: 24px;
			color: #ccc;
			margin-top: 8px;
		}

		#levelVisuals {
			margin-top: 30px;
			display: flex;
			flex-direction: column;
			gap: 12px;
			align-items: center;
		}

		#levelVisuals img {
			width: 40px;
			height: 40px;
		}

		#levelVisuals .item {
			display: flex;
			align-items: center;
			gap: 12px;
			color: #fff;
			font-size: 20px;
		}

		/* ===== Overlay de quiz ===== */
		#quizOverlay {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(0, 0, 0, 0.9);
			color: white;
			font-size: 24px;
			display: none;
			z-index: 30;
			flex-direction: column;
			justify-content: center;
			align-items: center;
			text-align: center;
		}

		.option {
			margin: 0 20px;
			font-size: 20px;
			cursor: pointer;
			user-select: none;
		}

		#quizTimer {
			margin-top: 10px;
			font-size: 20px;
			color: #ccc;
		}

		/* ===== Pantallas de fin ===== */
		.endScreen {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(0, 0, 0, 0.8);
			color: white;
			display: none;
			flex-direction: column;
			justify-content: center;
			align-items: center;
			font-size: 32px;
			z-index: 40;
			text-align: center;
		}

		.endScreen button {
			margin-top: 20px;
			padding: 10px 20px;
			font-size: 20px;
			cursor: pointer;
			background: #444;
			color: white;
			border: none;
			border-radius: 5px;
		}

		.endScreen button:hover {
			background: #666;
		}

		.endScreen .stats {
			margin-top: 10px;
			font-size: 20px;
			color: #ccc;
		}

		/* corazones amarillos */
		.heart-yellow {
			color: gold;
		}

		.heart-yellow.empty {
			opacity: 0.3;
		}


		/* Animación CSS para el overlay de victoria */
		@keyframes fadeInScale {
			0% {
				opacity: 0;
				transform: scale(0.8);
			}

			100% {
				opacity: 1;
				transform: scale(1);
			}
		}

		.endScreen.win {
			animation: fadeInScale 0.8s ease-out forwards;
		}

		/*Menú*/
		.absolute.inset-0 {
			position: absolute;
			top: 0;
			right: 0;
			bottom: 0;
			left: 0;
		}

		.hidden {
			display: none;
		}

		.z-50 {
			z-index: 50;
		}

		/* Efecto 3D en los botones*/
		.menu-button {
			/*background: linear-gradient(to bottom, #4f4f4f, #2c2c2c);*/
			border: 2px solid #888;
			border-radius: 8px;
			box-shadow: 0 4px 0 #222;
			color: white;
			font-size: 18px;
			padding: 10px;
			cursor: pointer;
			transition: transform 0.1s ease;
		}

		.menu-button:active {
			transform: translateY(2px);
			box-shadow: 0 2px 0 #222;
		}

		.menu-button:disabled {
			opacity: 0.5;
			cursor: not-allowed;
			pointer-events: none;
			/* eliminar el efecto hover */
			background-color: #444;
			/* fondo gris oscuro */
			filter: grayscale(100%);
			/* escala de grises total */
		}

		.controls-list {
			display: flex;
			flex-direction: column;
			gap: 10px;
		}

		.controls-row {
			display: flex;
			align-items: center;
			gap: 16px;
		}

		.controls-key {
			min-width: 160px;
			/* ancho fijo para alinear todas las descripciones */
			display: flex;
			gap: 6px;
			align-items: center;
		}

		.controls-desc {
			flex: 1;
		}

		.key-badge {
			display: inline-block;
			padding: 2px 8px;
			border: 1px solid #555;
			border-bottom-width: 3px;
			border-radius: 6px;
			background: #222;
			font-weight: 700;
			font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
		}

		#scoreLevel {
			display: flex;
			gap: 12px;
			align-items: center;
			font-size: 26px;
			color: gold;
		}

		#levelIndicator {
			font-size: 18px;
			color: #aaa;
		}

		#achievementsOverlay .grid>div:nth-child(-n+6) {
			border-bottom: 1px solid #666;
			padding-bottom: 4px;
		}

		#ver-logros,
		#ver-logros-victoria {
			transition: background-color 0.2s ease;
		}

		.scrollable-content {
			max-height: 90vh;
			overflow-y: auto;
			padding-right: 1rem;
			/* espacio para la barra */
		}

		.scrollable-content::-webkit-scrollbar {
			width: 8px;
		}

		.scrollable-content::-webkit-scrollbar-thumb {
			background-color: #888;
			border-radius: 4px;
		}

		.scrollable-content::-webkit-scrollbar-thumb:hover {
			background-color: #555;
		}
	</style>
</head>

<body>
	<div id="gameContainer">
		<!-- >>>>>> MENÚ PRINCIPAL <<<<<< -->
		<div id="mainMenu" class="absolute inset-0 bg-black bg-opacity-90 flex items-center justify-center z-50">
			<div class="bg-gray-800 p-8 rounded-lg text-white space-y-4 text-center w-64">
				<h1 class="text-3xl font-bold">NÁVEX</h1>
				<button id="btnPlay" class="menu-button bg-blue-600 hover:bg-blue-500 w-full">Jugar</button>
				<button id="btnPlayInfinite"
					class="menu-button bg-blue-700 hover:bg-blue-600 disabled:bg-gray-700 disabled:opacity-50 disabled:cursor-not-allowed w-full">Jugar
					∞</button>
				<button id="btnControls" class="menu-button bg-green-600 hover:bg-green-500 w-full">Controles</button>
				<button id="btnSoundMenu" class="menu-button bg-yellow-600 hover:bg-yellow-500 w-full">Sonido
					OFF</button>
				<button id="btnAchievements"
					class="menu-button bg-purple-600 hover:bg-purple-500 w-full">Logros</button>
				<div class="mt-4 text-gray-400 text-xs">
					<p>De Álex y David (López)</p>
					<p>Versión 1.0 (beta)</p>
				</div>

			</div>
		</div>

		<!-- >>>>>> OVERLAY CONTROLES <<<<<< -->
		<div id="controlsOverlay"
			class="absolute inset-0 bg-black bg-opacity-90 hidden z-50 flex items-center justify-center">
			<div
				class="bg-gray-800 p-6 rounded-lg text-white w-[32rem] max-h-[90vh] overflow-y-auto scrollable-content">
				<!-- max-h-[90vh] → hace que el recuadro nunca supere el 90% de la altura de la ventana.
				overflow-y-auto → activa la barra de desplazamiento solo si es necesario.
				scrollable-content → nombre del estilo CSS usado-->
				<h2 class="text-xl mb-4 text-center" style="color: gold;">CONTROLES</h2>
				<div class="controls-list">
					<div class="controls-row">
						<span class="controls-key">
							<kbd class="key-badge">←</kbd> / <kbd class="key-badge">→</kbd>
						</span>
						<span class="controls-desc">Mover la nave</span>
					</div>

					<div class="controls-row">
						<span class="controls-key">
							<kbd class="key-badge">Espacio</kbd>
						</span>
						<span class="controls-desc">Disparar</span>
					</div>

					<div class="controls-row">
						<span class="controls-key">
							<kbd class="key-badge">M</kbd>
						</span>
						<span class="controls-desc">Silenciar / Reactivar sonido</span>
					</div>

					<div class="controls-row">
						<span class="controls-key">
							<kbd class="key-badge">P</kbd>
						</span>
						<span class="controls-desc">Pausa</span>
					</div>

					<div class="controls-row">
						<span class="controls-key">
							<kbd class="key-badge">←</kbd> / <kbd class="key-badge">↑</kbd> / <kbd
								class="key-badge">→</kbd>
						</span>
						<span class="controls-desc">Elegir respuesta a las preguntas</span>
					</div>
					<hr class="my-4 border-gray-600">
					<p class="text-xl text-gray-300 mb-2 text-center">
						<span class="text-yellow-400">OBJETIVO:</span> Destruye enemigos y recolecta objetos para
						alcanzar la puntuación del nivel.
					</p>
					<!--<hr class="my-4 border-gray-600">-->
					<p class="text-xl text-gray-300 mb-2 text-center">
						Supera todos los niveles del juego para desbloquear el Modo Infinito (<span
							class="text-yellow-400">Jugar ∞</span>)
					</p>

				</div>
				<button onclick="hideControls()"
					class="mt-6 w-full py-2 bg-blue-600 rounded hover:bg-blue-500">Volver</button>
			</div>
		</div>

		<!-- >>>>>> OVERLAY LOGROS <<<<<< -->
		<div id="achievementsOverlay"
			class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
			<!-- <div class="bg-gray-800 text-white rounded-lg p-6 w-[40rem] max-h-[90vh] overflow-y-auto">-->
			<div
				class="bg-gray-800 p-6 rounded-lg text-white w-[42rem] max-h-[90vh] overflow-y-auto scrollable-content">
				<!-- max-h-[90vh] → hace que el recuadro nunca supere el 90% de la altura de la ventana.
				overflow-y-auto → activa la barra de desplazamiento solo si es necesario.
				scrollable-content → nombre del estilo CSS usado-->
				<h2 class="text-xl mb-4 text-center" style="color: gold;">RÉCORDS MODO CAMPAÑA</h2>

				<div class="grid grid-cols-[140px_repeat(5,minmax(0,1fr))] gap-4 text-center">
					<!-- Fila 1:  Encabezado -->
					<div></div> <!-- celda vacía -->
					<div class="font-semibold">Tiempo</div>
					<div class="font-semibold">Preguntas</div>
					<div class="font-semibold">Aciertos</div>
					<div class="font-semibold">Fallos</div>
					<div class="font-semibold">Nivel</div>

					<!-- Fila 2: Última partida -->
					<div class="font-semibold  whitespace-nowrap" style="color: cyan;">Última partida</div>
					<div id="achvTime">—:—</div>
					<div id="achvAnswers">0</div>
					<div id="achvCorrects">0 (0%)</div>
					<div id="achvFails">0 (0%)</div>
					<div id="achvLevel">—</div>

					<!-- Fila 3: Mejor tiempo -->
					<div id="recBestTimeName" style="color: cyan;"></div>
					<div id="recBestTimeTime"><strong>—:—</strong></div>
					<div id="recBestTimeQuestions">—</div>
					<div id="recBestTimeCorrects">—</div>
					<div id="recBestTimeFails">—</div>
					<div id="recBestTimeLevel">—</div>

					<!-- Fila 4: Más aciertos -->
					<div id="recBestCorrName" style="color: cyan;"></div>
					<div id="recBestCorrTime">—:—</div>
					<div id="recBestCorrQuestions">—</div>
					<div id="recBestCorrCorrects"><strong>—</strong></div>
					<div id="recBestCorrFails">—</div>
					<div id="recBestCorrLevel">—</div>
				</div>
				<br>

				<h2 class="text-xl mb-4 text-center" style="color: gold;">RÉCORDS MODO INFINITO</h2>
				<div class="grid grid-cols-[140px_repeat(5,minmax(0,1fr))] gap-4 text-center">
					<div></div>
					<div class="font-semibold">Tiempo</div>
					<div class="font-semibold">Preguntas</div>
					<div class="font-semibold">Aciertos</div>
					<div class="font-semibold">Fallos</div>
					<div class="font-semibold">Puntuación</div>

					<div class="font-semibold whitespace-nowrap" style="color: cyan;">Última partida ∞</div>
					<div id="achvInfTime">—:—</div>
					<div id="achvInfAnswers">0</div>
					<div id="achvInfCorrects">0 (0%)</div>
					<div id="achvInfFails">0 (0%)</div>
					<div id="achvInfScore">0</div>

					<div id="recInfBestTimeName" style="color: cyan;"></div>
					<div id="recInfBestTimeTime"><strong>—:—</strong></div>
					<div id="recInfBestTimeQuestions">—</div>
					<div id="recInfBestTimeCorrects">—</div>
					<div id="recInfBestTimeFails">—</div>
					<div id="recInfBestTimeScore">—</div>

					<div id="recInfBestCorrName" style="color: cyan;"></div>
					<div id="recInfBestCorrTime">—:—</div>
					<div id="recInfBestCorrQuestions">—</div>
					<div id="recInfBestCorrCorrects"><strong>—</strong></div>
					<div id="recInfBestCorrFails">—</div>
					<div id="recInfBestCorrScore">—</div>

					<div id="recInfBestScoreName" style="color: cyan;"></div>
					<div id="recInfBestScoreTime">—:—</div>
					<div id="recInfBestScoreQuestions">—</div>
					<div id="recInfBestScoreCorrects">—</div>
					<div id="recInfBestScoreFails">—</div>
					<div id="recInfBestScoreScore"><strong>—</strong></div>
				</div>
				<br>

				<h2 class="text-xl mb-4 text-center" style="color: gold;">LOGROS</h2>
				<div id="medallas" class="mt-6 space-y-4">
					<div class="flex items-center">
						<img id="medalla-aciertos_10" src="" alt="medalla-aciertos_10" class="w-12 h-12 mr-4">
						<span>Responde correctamente 10 preguntas.</span>
					</div>
					<div class="flex items-center">
						<img id="medalla-aciertos_50" src="" alt="medalla-aciertos_50" class="w-12 h-12 mr-4">
						<span>Responde correctamente 50 preguntas.</span>
					</div>
					<div class="flex items-center">
						<img id="medalla-aciertos_25" src="" alt="medalla-aciertos25" class="w-12 h-12 mr-4">
						<span>No falles ninguna pregunta y acierta, al menos, 25.</span>
					</div>
					<div class="flex items-center">
						<img id="medalla-veloz" src="" alt="medalla-veloz" class="w-12 h-12 mr-4">
						<span>Completa el juego en menos de 10 minutos.</span>
					</div>
				</div>

				<button onclick="hideAchievements()" class="mt-6 w-full py-2 bg-blue-600 rounded hover:bg-blue-500">
					Volver
				</button>
			</div>
		</div>


		<!-- HUD -->
		<div id="hud">
			<div class="row1">
				<div id="lives"></div>
				<div id="scoreLevel" style="display:flex; gap:12px; align-items:center;">
					<span id="score"></span>
					<span id="levelIndicator"></span>
				</div>
			</div>

			<div class="row2">
				<div id="quizStats">Aciertos: 0 | Fallos: 0</div>
				<div class="hud-right">
					<span id="debugIcon" class="select-none text-white text-2xl ml-4">🔧</span>
					<span id="time">🕒 00:00</span>
					<span id="muteIcon" class="select-none text-white text-2xl ml-4">🔊</span>
				</div>
			</div>
		</div>

		<!-- Canvas -->
		<canvas id="gameCanvas"></canvas>

		<!-- Overlay instrucciones -->
		<div id="levelOverlay">
			<h1 id="levelMessage" style="font-size: 48px; font-weight: bold; text-shadow: 2px 2px 8px #ff0;">Nivel 1
			</h1>
			<div id="levelVisuals"></div>
		</div>

		<!-- Overlay quiz -->
		<div id="quizOverlay">
			<div id="quizQuestion"></div>
			<div style="margin-top:20px;">
				<span id="option0" class="option">⬅️</span>
				<span id="option1" class="option">⬆️</span>
				<span id="option2" class="option">➡️</span>
			</div>
			<div id="quizTimer"></div>
		</div>

		<!-- Game Over -->
		<div id="gameOverScreen" class="endScreen">
			<div>¡Te han eliminado!</div>
			<div id="endStats" class="stats"></div>
			<button id="restartBtn">Volver a empezar</button>
			<button id="ver-logros" class="mt-4 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">Ver
				logros</button>
			<button id="btnMenu" class="mt-4 w-48 py-2 bg-blue-600 rounded hover:bg-blue-500">Ir a Menú</button>
		</div>

		<!-- Victoria -->
		<div id="winScreen" class="endScreen">
			<div>🎉 ¡Has ganado!</div>
			<div id="endStatsWin" class="stats"></div>
			<button id="restartWinBtn">Volver a empezar</button>
			<button id="ver-logros-victoria" class="mt-4 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">Ver
				logros</button>
			<button id="btnMenu" class="mt-4 w-48 py-2 bg-blue-600 rounded hover:bg-blue-500">Ir a Menú</button>
		</div>

		<!-- Crea un canvas encima de todo para el confeti y los fuegos artificiales -->
		<canvas id="celebrationCanvas"
			style="position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; display:none;"></canvas>


		<!-- Declara y precarga el audio -->
		<audio id="shotSound" src="Sonidos/retro-laser-1.mp3" preload="auto"></audio>
		<audio id="explosionSound" src="Sonidos/explosion6.mp3" preload="auto"></audio>
		<audio id="explosionShip" src="Sonidos/explosion7.mp3" preload="auto"></audio>
		<audio id="explosionSatellite" src="Sonidos/explosion2.mp3" preload="auto"></audio>
		<audio id="victoryMusic" src="Sonidos/victory.mp3" preload="auto"></audio>
		<audio id="bgMusic" src="Sonidos/AmazingFuture.mp3" preload="auto" loop></audio>

	</div>

	<script>
		// DEBUG ------
		let inmortal = false;
		let qPressCount = 0;
		let lastQPressTime = 0;
		let debugMode = false
		//-------------

		// Variables para el modo infinito
		let isInfiniteMode = false;
		let nextShipSpawnTime = null;
		let nextSatelliteSpawnTime = null;
		let lastGameWasInfinite = false;
		let campaignDone = false;

		// ===== Carga de imágenes =====
		const playerImage = new Image();
		playerImage.src = "Imágenes/nave.png";
		const rockImage = new Image();
		rockImage.src = "Imágenes/roca.png";
		const strongRockImage = new Image();
		strongRockImage.src = "Imágenes/rocaFuerte.png";
		const bonusImage = new Image();
		bonusImage.src = "Imágenes/bonus.png";
		const powerUpImage = new Image();
		powerUpImage.src = "Imágenes/powerup.png";
		const enemyImage = new Image();
		enemyImage.src = "Imágenes/naveEnemiga_1.png";
		const shieldBonusImage = new Image();
		shieldBonusImage.src = "Imágenes/Escudo.png";
		const laserImage = new Image();
		laserImage.src = "Imágenes/naveLaser.png";
		const fractalShipImage = new Image();
		fractalShipImage.src = "Imágenes/naveFractal.png";
		const fractalProjectileImage = new Image();
		fractalProjectileImage.src = "Imágenes/proyectilFractal.png";
		const cometImage = new Image();
		cometImage.src = "Imágenes/cometa.png";
		const satelliteImage = new Image();
		satelliteImage.src = "Imágenes/Satélite1.png";
		const blindSatImage = new Image();
		blindSatImage.src = "Imágenes/Satélite2.png";
		const absorberSatImage = new Image();
		absorberSatImage.src = "Imágenes/Satélite3b.png";
		const mirrorImage = new Image();
		mirrorImage.src = "Imágenes/naveEspejo.png";
		const imagePaths = {
			medallas: {
				aciertos_10: "Imágenes/medalla02.png",
				aciertos_25: "Imágenes/medalla01.png",
				aciertos_50: "Imágenes/medalla05.png",
				veloz: "Imágenes/medalla07.png"
			}
		};
		let medallasEstado = {
			aciertos_10: false,
			aciertos_25: false,
			aciertos_50: false,
			veloz: false
		};

		// Cargar logros conseguidos desde localStorage si existe
		const guardado = localStorage.getItem("medallasEstado");
		if (guardado) {
			try {
				medallasEstado = JSON.parse(guardado);
			} catch (e) {
				console.warn("Error al cargar medallas guardadas:", e);
			}
		}
		// Modo campaña
		let bestTimeRecord = JSON.parse(localStorage.getItem("bestTimeRecord")) || null;
		let bestCorrectsRecord = JSON.parse(localStorage.getItem("bestCorrectsRecord")) || null;
		// Modo Infinito
		let bestTimeRecordInfinite = JSON.parse(localStorage.getItem("bestTimeRecordInfinite")) || null;
		let bestCorrectsRecordInfinite = JSON.parse(localStorage.getItem("bestCorrectsRecordInfinite")) || null;
		let bestScoreRecordInfinite = JSON.parse(localStorage.getItem("bestScoreRecordInfinite")) || null;
		// Records por defecto en modo campaña si aún no hay ninguno
		if (!bestTimeRecord) {
			bestTimeRecord = {
				name: "TORTUGA",
				stats: {
					timeSec: 1818,         // tiempo alto para que sea fácil de superar
					answers: 0,
					corrects: 0,
					correctPct: 0,
					fails: 0,
					failPct: 0,
					level: 11
				}
			};
		}
		if (!bestCorrectsRecord) {
			bestCorrectsRecord = {
				name: "Listillo",
				stats: {
					timeSec: 652,
					answers: 0,
					corrects: 3,
					correctPct: 60,
					fails: 2,
					failPct: 40,
					level: 3
				}
			};
		}
		// Records por defecto para el modo infinito  si aún no hay ninguno
		if (!bestTimeRecordInfinite) {
			bestTimeRecordInfinite = {
				name: "Superviviente",
				stats: { timeSec: 60, answers: 2, corrects: 1, correctPct: 50, fails: 1, failPct: 50, score: 2500 }
			};
		}
		if (!bestCorrectsRecordInfinite) {
			bestCorrectsRecordInfinite = {
				name: "Sabiondo",
				stats: { timeSec: 30, answers: 5, corrects: 4, correctPct: 80, fails: 1, failPct: 20, score: 1000 }
			};
		}
		if (!bestScoreRecordInfinite) {
			bestScoreRecordInfinite = {
				name: "Avaro",
				stats: { timeSec: 30, answers: 1, corrects: 0, correctPct: 0, fails: 1, failPct: 100, score: 3000 }
			};
		}

		// Icono para indicar si se pueden usar los trucos para debug (o cheat)
		const debugIcon = document.getElementById("debugIcon");
		debugIcon.classList.add("hidden");	// Inicialmente oculto

		// Audio
		let muted = true;// Empezamos con el sonido apagado
		const muteIcon = document.getElementById("muteIcon");
		const shotSound = document.getElementById('shotSound');
		const explosionSound = document.getElementById("explosionSound");
		const explosionShip = document.getElementById("explosionShip");
		const explosionSatellite = document.getElementById("explosionSatellite");
		const bgMusic = document.getElementById("bgMusic");


		// ===== Canvas =====
		const container = document.getElementById("gameContainer");
		const canvas = document.getElementById("gameCanvas");
		const ctx = canvas.getContext("2d");
		canvas.width = container.clientWidth;
		canvas.height = container.clientHeight;

		// ===== Variables =====
		let lives = 3;
		const maxLives = 3;
		let score = 0;
		let startTime = Date.now();
		let quizCorrects = 0;
		let quizFails = 0;
		const rockSpeed = 3;
		const bulletSpeed = 7;
		let extraLives = 0;   // 0–3, solo se llena en Nivel 11
		let gameWon = false		// Bandera para indicar si se ha acabado el último nivel

		let currentLevel = 0;
		const levels = [
			{
				goal: 500,
				message: "Nivel 1",
				visuals: [
					{ img: rockImage, text: "¡Destrúyelo!" },
					{ img: bonusImage, text: "Mejora el disparo" },
					{ img: powerUpImage, text: "Recupérate" }
				],
				rockRate: 0.03,	//Porcentaje de frames en los que se crea una roca
				strongProb: 0,	//(entre 0 y 1) proporción de rocas que serán fuertes.
				cometRate: 0,    // probabilidad de crear un cometa por frame
				satelliteRate: 0,
				blindSatRate: 0,
				absorberSatRate: 0
			},
			{
				goal: 1000,
				message: "Nivel 2",
				visuals: [
					{ img: strongRockImage, text: "¡Es más dura!" },
					{ img: bonusImage, text: "¡Doble disparo!" }
				],
				rockRate: 0.03,
				strongProb: 0.5,
				cometRate: 0,
				satelliteRate: 0,
				blindSatRate: 0,
				absorberSatRate: 0
			},
			{
				goal: 1500,
				message: "Nivel 3",
				visuals: [
					{ img: strongRockImage, text: "¡Muchas más!" }
				],
				rockRate: 0.06,
				strongProb: 0.85,
				cometRate: 0,
				satelliteRate: 0,
				blindSatRate: 0,
				absorberSatRate: 0
			},
			{
				goal: 2000,
				message: "Nivel 4",
				visuals: [
					{ img: enemyImage, text: "¡Enemigos!" },
					{ img: shieldBonusImage, text: "Escudo" }
				],
				rockRate: 0.03,
				strongProb: 0.5,
				cometRate: 0,
				satelliteRate: 0,
				blindSatRate: 0,
				absorberSatRate: 0
			},
			{
				goal: 1000,
				message: "Nivel 5",
				visuals: [
					{ img: cometImage, text: "¡Cometas!" }
				],
				rockRate: 0.03,
				strongProb: 0.5,
				cometRate: 0.02,    // probabilidad de crear un cometa por frame
				satelliteRate: 0,
				blindSatRate: 0,
				absorberSatRate: 0
			},
			{
				goal: 1500,
				message: "Nivel 6",
				visuals: [
					{ img: laserImage, text: "¡Rayo láser!" }
				],
				rockRate: 0.03,
				strongProb: 0.5,
				cometRate: 0.005,
				satelliteRate: 0,
				blindSatRate: 0,
				absorberSatRate: 0
			},
			{
				goal: 1500,
				message: "Nivel 7",
				visuals: [
					{ img: fractalShipImage, text: "Ataque fragmentario" }
				],
				rockRate: 0.03,
				strongProb: 0.5,
				cometRate: 0.005,
				satelliteRate: 0,
				blindSatRate: 0,
				absorberSatRate: 0
			},
			{
				goal: 2000,
				message: "Nivel 8",
				visuals: [
					{ img: satelliteImage, text: "¡Te paraliza temporalmente!" },
					{ img: bonusImage, text: "¡Disparo cuádruple!" }
				],
				rockRate: 0.03,         // tasa de aparición de rocas
				strongProb: 0.5,
				cometRate: 0.001,
				satelliteRate: 0.005,    // probabilidad por frame
				blindSatRate: 0,
				absorberSatRate: 0
			},
			{
				goal: 3000,
				message: "Nivel 9",
				visuals: [
					{ img: blindSatImage, text: "¡Te cegará!" }
				],
				rockRate: 0.03,
				strongProb: 0.5,
				cometRate: 0.001,
				satelliteRate: 0,    // Satélites paralizadores
				blindSatRate: 0.005,    // probabilidad por frame de generar un satélite cegador
				absorberSatRate: 0
			},
			{
				goal: 2000,
				message: "Nivel 10",
				visuals: [
					{ img: absorberSatImage, text: "¡Agujero negro!" }
				],
				rockRate: 0.03,
				strongProb: 0.5,
				cometRate: 0.005,
				satelliteRate: 0,
				blindSatRate: 0,
				absorberSatRate: 0.005 // nueva propiedad para este tipo
			},
			{
				goal: 10000,
				message: "Nivel 11",
				visuals: [
					{ img: mirrorImage, text: "¡¡¡ENEMIGO FINAL!!!" }
				],
				rockRate: 0.03,
				strongProb: 0.5,
				cometRate: 0.005,
				satelliteRate: 0,
				blindSatRate: 0,
				absorberSatRate: 0.005
			},
			{
				goal: Infinity,
				message: 'Modo ∞',
				visuals: [
					{ img: playerImage, text: '¡De todo!' }
				],
				rockRate: 0.03,
				strongProb: 0.5,
				cometRate: 0.005,
				satelliteRate: 0.001,
				blindSatRate: 0.001,
				absorberSatRate: 0.001
			}


		];

		let scoreGoal = levels[0].goal;
		let gameRunning = true;
		let paused = false;
		let levelActive = false;
		let quizActive = false;

		// Disparo
		let lastShotTime = 0;
		let shotGrade = 0;
		const SHOT_GRADES = [
			{ type: "simple", cooldown: 200 },
			{ type: "simple", cooldown: 150 },
			{ type: "simple", cooldown: 100 },
			{ type: "double", cooldown: 100 },
			{ type: "quadruple", cooldown: 100 }
		];

		//Grado máximo permitido del disparo (según el nivel)
		function maxGradeForLevel(level) {
			if (level >= 7) return 4;    // a partir de Nivel 8 permitimos índice 4 (cuádruple)
			if (level >= 1) return 3;    // Nivel 2→índice 3 (doble)
			return 2;                     // Nivel 1→índice 2 (simple rápido)
		}

		// Quiz
		let quizStart = 0;
		let quizIdx = -1;
		let quizQuestion = "";
		let quizOptions = [];
		let quizOrigin = null;  // "disparo" o "vida"
		let quizAnswered = false;

		// Jugador
		let player = {
			x: canvas.width / 2 - 24,
			y: canvas.height - 80,
			w: 48,
			h: 48,
			shieldLevel: 0,
			lastHitTime: 0,
			invincibleTime: 2000, // Tiempo de inmortalidad (al ser golpeado)
			flashTime: 0,
			shieldTouchStart: 0,  // timestamp de inicio de impacto láser
			speed: 6,
			paralyzeEnd: 0    // timestamp hasta el que está paralizado
		};

		// Entidades
		const stars = Array.from({ length: 150 }, () => ({
			x: Math.random() * canvas.width,
			y: Math.random() * canvas.height,
			size: Math.random() * 2 + 1,
			speed: Math.random() * 0.5 + 0.2
		}));
		const bullets = [];
		const rocks = [];
		const bonuses = [];
		const shieldBonuses = [];
		const powerUps = [];
		const explosions = [];
		const popups = []; //Texto con los puntos obtenidos
		let enemies = [];
		let enemyBullets = [];
		let laserShips = [];
		let fractalShips = [];
		const fractalBullets = [];
		const comets = [];
		const satellites = [];
		const waveSlices = [];
		const blindSatellites = [];
		const blindWaves = [];
		const blindWaveSpeed = 8;	// px por frame
		const absorberSatellites = [];
		let mirrorShip = null;
		let mirrorDefeated = false;    // evita respawns tras destruirla
		let mirrorLastShot = 0;
		const mirrorBullets = [];



		// ===== Configuración de puntuación (por eliminar enemigos) =====
		const POINTS = {
			rock: 10,           // roca débil
			strongRock: 50,     // roca fuerte
			bonus: 100,         // Bonus de disparo acertado (si ya teníamos el máximo)
			powerUp: 100,       // Vida recogida (si ya teníamos el máximo)
			shield: 100,		// Bonus de escudo acertado (si ya teníamos el máximo)
			basicEnemy: 200,	// destruir nave enemiga básica
			laser: 500,			// nave láser
			fractal: 500,		// nave fractal
			comet: 60, 			// cometa
			satellite: 150,     // satélite paralizador
			mirror: 10000		// nave espejo
		}

		// Código de celebración
		const victoryMusic = document.getElementById("victoryMusic");
		const confettiCanvas = document.getElementById("celebrationCanvas");
		const confCtx = confettiCanvas.getContext("2d");
		let confettiParticles = [];
		let celebrationLoopId;

		// Referencias al menú y overlays
		const mainMenu = document.getElementById("mainMenu");
		const controlsOverlay = document.getElementById("controlsOverlay");
		const achievementsOverlay = document.getElementById("achievementsOverlay");
		const btnPlayMenu = document.getElementById("btnPlay");
		const btnPlayInfinite = document.getElementById("btnPlayInfinite");
		const btnControlsMenu = document.getElementById("btnControls");
		const btnSoundMenu = document.getElementById("btnSoundMenu");
		const btnAchievements = document.getElementById("btnAchievements");
		const btnBackToMenu = document.querySelectorAll("#btnMenu"); // gameOver + win

		let lastRun = {
			level: 0,
			timeSec: 0,
			answers: 0,
			corrects: 0,
			fails: 0,
			correctPct: 0,
			failPct: 0
		};
		let lastRunInfinite = {
			timeSec: 0,
			answers: 0,
			corrects: 0,
			fails: 0,
			correctPct: 0,
			failPct: 0,
			score: 0
		};

		// ===== MENÚ =====
		// Ocultar/mostrar helpers
		function showMainMenu() {
			mainMenu.classList.remove("hidden");
			// pausa y resetea el juego
			gameRunning = false;
			resetEntities();

			// comprobar si está desbloqueado el modo infinito
			refreshInfiniteButton();
			// campaignDone = localStorage.getItem("campaignCompleted") === "true";
			// btnPlayInfinite.disabled = !campaignDone;
		}

		function hideMainMenu() {
			mainMenu.classList.add("hidden");
			gameRunning = true;
			showLevelOverlay();  // muestra primer overlay de nivel
			startBackgroundMusic();
			updateMuteIcon();
		}
		function showControls() { controlsOverlay.classList.remove("hidden"); }
		function hideControls() { controlsOverlay.classList.add("hidden"); }
		function showAchievements() {
			captureLastRun();
			checkRecords();
			updateAchievementsOverlay();
			updateAchievementsOverlayInfinite();
			actualizarMedallas();
			achievementsOverlay.classList.remove("hidden");
		}
		function hideAchievements() { achievementsOverlay.classList.add("hidden"); }

		// Botones del menú
		btnControlsMenu.onclick = () => {
			showControls();
		};

		btnSoundMenu.onclick = () => {
			muted = !muted;
			updateMuteIcon();
			btnSoundMenu.textContent = muted ? "Sonido OFF" : "Sonido ON";
		};


		btnAchievements.onclick = () => {
			showAchievements();
		};

		// "Menú Principal" tras Game Over o Win
		btnBackToMenu.forEach(b => {
			b.onclick = () => {
				// reset de variables
				resetBasicVariables();
				isInfiniteMode = false;
				extraLives = 0; // si usas vidas extra en nivel 11
				currentLevel = 0;
				scoreGoal = levels[0].goal;

				resetPlayer();
				resetEntities();
				stopCelebration();

				// Ocultar pantallas de fin
				document.getElementById("gameOverScreen").style.display = "none";
				document.getElementById("winScreen").style.display = "none";

				updateLivesDisplay();
				updateHUD();

				// mostrar menú principal
				showMainMenu();
			};
		});

		btnPlayMenu.onclick = () => {
			resetBasicVariables();
			isInfiniteMode = false; 	// Desactivamos modo infinito
			hideMainMenu();				// cerramos menú
			startBackgroundMusic();
			requestAnimationFrame(gameLoop);
		};

		btnPlayInfinite.onclick = () => {
			campaignDone = localStorage.getItem("campaignCompleted") === "true";
			if (!campaignDone) {
				alert("Completa primero todos los niveles para desbloquear el modo infinito");
				return;
			}
			resetBasicVariables();
			isInfiniteMode = true; 		// activamos modo infinito

			// Apunta al nivel infinito (es el último del array)
			currentLevel = levels.length - 1;
			// Nunca se cumple score ≥ Infinity
			scoreGoal = Infinity;

			startTime = Date.now();         // iniciamos cronómetro
			hideMainMenu();                      // cerramos menú
			startBackgroundMusic();
			requestAnimationFrame(gameLoop);
		};


		// ===== HUD =====
		function updateLivesDisplay() {
			const div = document.getElementById("lives");
			div.innerHTML = "";

			// 3 corazones rojos (maxLives = 3)
			for (let i = 0; i < maxLives; i++) {
				const s = document.createElement("span");
				s.className = "heart" + (i >= lives ? " empty" : "");
				s.textContent = "❤️";
				div.appendChild(s);
			}

			// En Nivel 11 (índice 10) añadimos hasta 3 corazones amarillos
			if (currentLevel === 10) {
				for (let j = 0; j < 3; j++) {
					const s = document.createElement("span");
					// usa otra clase para vacío/lleno, por ejemplo "heart-yellow"
					s.className = "heart heart-yellow" + (j >= extraLives ? " empty" : "");
					s.textContent = "💛";
					div.appendChild(s);
				}
			}
		}

		function updateHUD() {
			if (isInfiniteMode) {
				document.getElementById("score").textContent = `${score}`;
			} else {
				document.getElementById("score").textContent = `${score} / ${scoreGoal}`;
			}

			const elapsed = Math.floor((Date.now() - startTime) / 1000);
			const mm = String(Math.floor(elapsed / 60)).padStart(2, "0");
			const ss = String(elapsed % 60).padStart(2, "0");
			document.getElementById("time").textContent = `🕒 ${mm}:${ss}`;
			//document.getElementById("levelIndicator").textContent =	`Nivel ${currentLevel + 1}`;

			const levelLabel = isInfiniteMode ? "∞" : `Nivel ${currentLevel + 1}`;
			document.getElementById("levelIndicator").textContent = levelLabel;

			document.getElementById("quizStats").textContent = `Aciertos: ${quizCorrects} | Fallos: ${quizFails}`;

		}

		// ===== Overlay nivel =====
		function showLevelOverlay() {
			levelActive = true;
			const ov = document.getElementById("levelOverlay");
			document.getElementById("levelMessage").textContent =
				levels[currentLevel].message;


			const vis = document.getElementById("levelVisuals");
			vis.innerHTML = "";
			levels[currentLevel].visuals.forEach(v => {
				const row = document.createElement("div");
				row.className = "item";
				const img = document.createElement("img");
				img.src = v.img.src;
				const lbl = document.createElement("span");
				lbl.textContent = v.text;
				row.append(img, lbl);
				vis.appendChild(row);
			});

			ov.style.display = "flex";
			setTimeout(() => {
				ov.style.display = "none";
				levelActive = false;
			}, 3000);

			if (currentLevel === 3) {	//Nivel 4 (índice 3)
				spawnEnemy("left");  // primera nave
				spawnEnemy("right");  // segunda nave
			}

			if (currentLevel === 5) {	//Nivel 6 (índice 5)
				const side = Math.random() < 0.5 ? "left" : "right";
				spawnLaserShip(side);
			}

			if (currentLevel === 6) {	//Nivel 7 (índice 6)
				spawnFractalShip("left");
				spawnFractalShip("right");
			}

			if (currentLevel === 7) {	//Nivel 8 (índice 7)
				spawnFractalShip("left");
			}

			if (currentLevel === 8) {	//Nivel 9 (índice 8)
				spawnEnemy("left");  // primera nave
				spawnEnemy("right");  // segunda nave
				//spawnEnemy();
				//spawnEnemy();
			}

			if (currentLevel === 9) {	//Nivel 10 (índice 9)
				spawnFractalShip("left");
				spawnEnemy("right");

			}
		}

		// ===== Generar entidades =====
		function drawPopups() {
			popups.forEach((p, i) => {
				ctx.font = '16px sans-serif';
				ctx.fillStyle = `rgba(255, 255, 255, ${p.alpha})`;
				ctx.fillText(p.text, p.x, p.y);
				p.y -= 1;           // sube lentamente
				p.alpha -= 0.02;    // se va desvaneciendo
				if (p.alpha <= 0) popups.splice(i, 1);
			});
		}

		function spawnRock() {
			const strong = Math.random() < levels[currentLevel].strongProb;
			rocks.push({
				x: Math.random() * (canvas.width - 40),
				y: -40,
				size: 40,
				hp: strong ? 3 : 1,
				strong
			});
		}

		function spawnComet() {
			const size = 30;	//Tamaño del cometa
			let x, y, dx, dy;
			const edge = Math.random();

			if (edge < 0.33) {
				// Desde arriba
				x = Math.random() * canvas.width;
				y = -size;
				// dy = 2 + Math.random() * 2;
				// dx = (Math.random() - 0.5) * 2;
				if (Math.random() < 0.5) {
					dx = 1;
				} else {
					dx = -1;
				}
				dy = 3;
			}
			else if (edge < 0.66) {
				// Desde izquierda (25% superior)
				x = -size;
				y = Math.random() * canvas.height * 0.25;
				// dx = 2 + Math.random() * 2;
				// dy = 2 + Math.random() * 2;
				dx = 3;
				dy = 3;
			}
			else {
				// Desde derecha (25% superior)
				x = canvas.width + size;
				y = Math.random() * canvas.height * 0.25;
				// dx = - (2 + Math.random() * 2);
				// dy = 2 + Math.random() * 2;
				dx = -3;
				dy = 3;
			}

			comets.push({
				x,
				y,
				size,
				hp: 1,
				dx,
				dy
			});
		}

		function spawnBonus() {
			if (Math.random() < 0.004) {
				bonuses.push({ x: Math.random() * (canvas.width - 34), y: -30, size: 34 });
			}
		}

		function spawnPowerUp() {
			let powerUPrate
			if (currentLevel === 10) {	//Nivel 11 (índice 10)
				powerUPrate = 0.006;
			} else {
				powerUPrate = 0.002;
			}

			if (Math.random() < powerUPrate) {
				powerUps.push({ x: Math.random() * (canvas.width - 24), y: -30, size: 24 });
			}
		}

		function spawnShieldBonus() {
			if (Math.random() < 0.005) {
				shieldBonuses.push({
					x: Math.random() * (canvas.width - 34),
					y: -30,
					size: 34
				});
			}
		}
		function spawnEnemy(fromSide = null) {
			let x, dx, targetX;
			if (fromSide === "left") {
				x = -48;
				dx = 3;
				targetX = Math.random() * (canvas.width - 100) + 50;
			} else if (fromSide === "right") {
				x = canvas.width;
				dx = -3;
				targetX = Math.random() * (canvas.width - 100) + 50;
			} else {
				x = Math.random() * (canvas.width - 48);
				dx = 2;
				targetX = null;
			}

			enemies.push({
				x,
				y: 50,		// altura fija
				width: 48,
				height: 48,
				hp: 20,// Puntos de vida en cada momento (aquí, al crearlo,debe ser igual a hpIni)
				hpIni: 20,// Puntos de vida iniciales (para calcular barra de vida)
				dx: fromSide === "left" ? 2 : fromSide === "right" ? -2 : 2, // velocidad horizontal
				oscill: 0,	// para temblar al recibir daño

				// disparo en ráfaga
				burstShots: 5,
				shotsFired: 0,
				lastShotTime: 0,
				inBurst: true,
				burstStart: Date.now(),

				entering: fromSide !== null,
				targetX,
				spawnTime: Date.now(), // tiempo de aparición
				waiting: true           // estado de espera
			});
		}

		function spawnLaserShip(fromSide = null) {
			let x, dx;
			if (fromSide === "left") { x = -64; dx = 2; }
			if (fromSide === "right") { x = canvas.width; dx = -2; }
			if (!fromSide) {
				x = Math.random() * (canvas.width - 64);
				dx = Math.random() < 0.5 ? 2 : -2;
			}
			laserShips.push({
				x, y: 50,
				w: 48,
				h: 48,
				dx,
				hp: 100,// Puntos de vida en cada momento (aquí, al crearlo,debe ser igual a hpIni)
				hpIni: 100,// Puntos de vida iniciales
				oscill: 0,
				entering: !!fromSide,
				targetX: fromSide ? Math.random() * (canvas.width - 100) + 50 : null,
				spawnTime: Date.now(),
				waiting: true,
				lastShot: 0,
				cooldown: 2000, // 2s
				laserOn: false,
				laserStart: 0
			});
		}

		function spawnFractalShip(fromSide = null) {
			let x, dx;
			if (fromSide === "left") { x = -64; dx = 2; }
			if (fromSide === "right") { x = canvas.width; dx = -2; }
			if (!fromSide) {
				x = Math.random() * (canvas.width - 64);
				dx = Math.random() < 0.5 ? 2 : -2;
			}

			fractalShips.push({
				x,
				y: 50,
				w: 48,
				h: 48,
				dx,
				hp: 200,// Puntos de vida en cada momento (aquí, al crearlo,debe ser igual a hpIni)
				hpIni: 200,// Puntos de vida iniciales
				oscill: 0,
				entering: !!fromSide,
				targetX: fromSide ? Math.random() * (canvas.width - 100) + 50 : null,
				spawnTime: Date.now(),
				waiting: true,
				lastShot: Date.now(),
				cooldown: 1000 + 2000 * Math.random()
			});
		}

		function spawnSatellite() {
			if (Math.random() < levels[currentLevel].satelliteRate) {
				const size = 30;
				const side = Math.random() < 0.5 ? "left" : "right";
				const x = side === "left" ? -size : canvas.width + size;
				const y = 100;	// altura
				const dx = side === "left" ? 1 : -1;  // velocidad de desplazamiento

				satellites.push({
					x,
					y,
					size,
					dx,
					hp: 1,
					probShot: 0.02	// % de frames en los que disparará
				});
			}
		}

		function spawnWaveSlice(x, y, delay = 0) {
			waveSlices.push({
				x,                   // centro X de emisión
				y,                   // centro Y inicial (borde inferior del satélite)
				radius: 0,           // radio inicial
				maxRadius: canvas.height * 1.5,  // crecerá hasta cubrir toda la pantalla
				thickness: 3,        // grosor de línea
				expandSpeed: 4,      // pixels que crece el radio y avanza por frame
				delay,               // frames a esperar antes de empezar a dibujar. Permite escalonar las 3 ondas de la ráfaga.
				age: 0,              // contador interno de frames
				startAngle: Math.PI / 2 - Math.PI / 12,  // 75º
				endAngle: Math.PI / 2 + Math.PI / 12   // 105º → arco de 30º (apuntando hacia abajo)
			});
		}

		// Generar satélite cegador
		function spawnBlindSatellite() {
			if (Math.random() < levels[currentLevel].blindSatRate) {
				const size = 30;
				const side = Math.random() < 0.5 ? "left" : "right";
				const x = side === "left" ? -size : canvas.width + size;
				const y = 100;
				const dx = side === "left" ? 1 : -1;

				let tmin = 4000;
				let tmax = 6000;
				blindSatellites.push({
					x,
					y,
					size,
					dx,
					hp: 1,
					nextWaveTime: Date.now() + tmin + Math.random() * (tmax - tmin)
				});
			}
		}

		function spawnAbsorberSatellite() {
			// Si ya hay uno en pantalla, no generar otro
			if (absorberSatellites.length > 0) return;

			if (Math.random() < levels[currentLevel].absorberSatRate) {
				const size = 30;
				const side = Math.random() < 0.5 ? "left" : "right";
				const x = side === "left" ? -size : canvas.width + size;
				const y = 140;
				const dx = side === "left" ? 1 : -1;

				absorberSatellites.push({
					x,
					y,
					size,
					dx
				});
			}
		}

		function spawnMirrorShip() {
			if (mirrorShip || mirrorDefeated) return; // Si ya existe una o ya ha sido destruida

			mirrorShip = {
				x: canvas.width / 2 - player.w / 2,
				y: 50,
				w: player.w,
				h: player.h,
				shieldLevel: player.shieldLevel, // copia el escudo actual del jugador
				hp: 100,     // puntos de vida actuales
				hpIni: 100,   // para dibujar la barra
				vx: 3,              // velocidad horizontal
				evadeThreshold: 50  // distancia en px a la bala para reaccionar
			};
		}



		// ===== Dibujar =====
		// Dibuja y actualiza las explosiones
		function drawExplosions() {
			explosions.forEach((e, i) => {
				ctx.beginPath();
				ctx.arc(e.x, e.y, e.radius, 0, 2 * Math.PI);
				ctx.fillStyle = `rgba(255,165,0,${e.alpha})`;
				ctx.fill();
				e.radius += 2;
				e.alpha -= 0.04;
				if (e.alpha <= 0 || e.radius > e.maxRadius) {
					explosions.splice(i, 1);
				}
			});
		}

		//Estrellas de fondo
		function drawStars() {
			ctx.fillStyle = "white";
			stars.forEach(s => {
				ctx.beginPath();
				ctx.arc(s.x, s.y, s.size, 0, 2 * Math.PI);
				ctx.fill();
				s.y += s.speed;
				if (s.y > canvas.height) {
					s.y = 0; s.x = Math.random() * canvas.width;
				}
			});
		}

		//Dibujar nave del jugador
		function drawPlayer() {
			const now = Date.now();
			const flashing = now - player.lastHitTime < player.invincibleTime;
			const paralyzed = now < player.paralyzeEnd;

			ctx.save();

			// Si está paralizado, cambia el aspecto de la nave
			if (paralyzed) {
				ctx.globalAlpha = 0.5;	//semitransparente
				ctx.filter = 'grayscale(100%)';	//Gris
			}

			// Parpadear (por ejemplo si es inmortal tras perder una vida)
			if (flashing) {
				const blink = Math.floor((now - player.flashTime) / 100) % 2 === 0;
				if (!blink) return; // no dibujar en este frame
			}

			ctx.drawImage(playerImage, player.x, player.y, player.w, player.h);

			// DEBUG: caja de colisión del jugador
			// ctx.strokeStyle = "lime";
			// ctx.lineWidth = 1;
			// ctx.strokeRect(player.x, player.y, player.w, player.h);

			// Dibujar escudo si está activo
			if (player.shieldLevel > 0) {
				const colors = ["white", "blue", "red"];
				ctx.strokeStyle = colors[player.shieldLevel - 1];
				ctx.lineWidth = 1 + player.shieldLevel;	//Grosor del escudo (según el grado del escudo)
				ctx.beginPath();
				ctx.arc(
					player.x + player.w / 2,
					player.y + player.h / 2,
					player.w / 2 + 10,
					0, Math.PI * 2
				);
				ctx.stroke();
			}

			ctx.restore();
		}

		function drawBullets() {
			ctx.fillStyle = "yellow";
			bullets.forEach((b, i) => {
				// Paso por defecto (hacia arriba)
				let stepX = 0;
				let stepY = -bulletSpeed;

				// Si hay un satélite absorvedor en pantalla...
				if (absorberSatellites.length > 0) {
					const sat = absorberSatellites[0];  // sólo sale un satélite a la vez
					const cx = sat.x + sat.size / 2;
					const cy = sat.y + sat.size / 2;
					const bx = b.x + 2;     // centro aproximado de la bala
					const by = b.y + 5;
					const vx = cx - bx;
					const vy = cy - by;
					const dist = Math.hypot(vx, vy);

					const attractRadius = 200;  // Radio de atracción de las balas del jugador
					if (dist < attractRadius && dist > 0) {
						// normalizar y escalar
						stepX = (vx / dist) * bulletSpeed;
						stepY = (vy / dist) * bulletSpeed;
					}
				}

				// mover la bala
				b.x += stepX;
				b.y += stepY;

				// dibujarla
				ctx.fillRect(b.x, b.y, 4, 10);

			});
		}

		function drawRocks() {
			rocks.forEach(r => {
				const img = r.strong ? strongRockImage : rockImage;
				//Si es la roca más fuerte, se le reduce el tamaño con cda disparo.
				const scale = r.strong ? (0.7 + 0.1 * r.hp) : 1; // hp=3 → 1.0, hp=2 → 0.9, hp=1 → 0.8
				const size = r.size * scale;
				const offset = (r.size - size) / 2;

				ctx.drawImage(img, r.x + offset, r.y + offset, size, size);

				r.y += rockSpeed;
			});
		}

		function drawComets() {
			comets.forEach((c, i) => {
				ctx.drawImage(cometImage, c.x, c.y, c.size, c.size);

				c.x += c.dx;
				c.y += c.dy;
			});
		}

		//Bonus de disparo
		function drawBonuses() {
			bonuses.forEach(b => {
				ctx.drawImage(bonusImage, b.x, b.y, b.size, b.size);
				b.y += 2;
			});
		}

		//Bonus de Vidas
		function drawPowerUps() {
			powerUps.forEach(p => {
				ctx.drawImage(powerUpImage, p.x, p.y, p.size, p.size);
				p.y += 2;
			});
		}

		//Naves enemigas básicas
		function drawEnemies() {
			enemies.forEach(e => {
				const shake = Math.sin(e.oscill) * 4;
				const px = e.x + shake, py = e.y;
				ctx.drawImage(enemyImage, px, py, e.width, e.height);

				drawHealthBar(e); // Dibuja la barra de vida (roja por defecto)
			});
		}

		function drawSatellites() {
			satellites.forEach((s, i) => {
				ctx.drawImage(satelliteImage, s.x, s.y, s.size, s.size);
				s.x += s.dx;
			});
		}

		// Dibujar balas enemigas 
		function drawEnemyBullets() {
			ctx.fillStyle = "red";
			for (let i = enemyBullets.length - 1; i >= 0; i--) {
				const b = enemyBullets[i];
				ctx.fillRect(b.x, b.y, 4, 10);
				b.y += 5;
			}
		}

		function drawShieldBonuses() {
			shieldBonuses.forEach((s, i) => {
				ctx.drawImage(shieldBonusImage, s.x, s.y, s.size, s.size);
				s.y += 2;
			});
		}

		function drawLaserShips() {
			laserShips.forEach(s => {
				// temblor según s.oscill (por si le alcanza una bala)
				const shake = Math.sin(s.oscill) * 5;
				const xPos = s.x + shake;

				ctx.drawImage(laserImage, xPos, s.y, s.w, s.h);

				drawHealthBar(s, "lime");	// Dibuja la barra de vida
			});
		}

		function drawLaserBeams() {
			laserShips.forEach(s => {
				if (!s.laserOn) return;

				// Calcular la posición X del rayo y su punto de salida (topY)
				const cx = s.x + s.w / 2;
				const topY = s.y + s.h;

				// Centro y radio del escudo
				const shieldCX = player.x + player.w / 2;
				const shieldCY = player.y + player.h / 2;
				const R = player.w / 2 + 10;

				// Distancia horizontal entre rayo y centro del escudo
				const dx = shieldCX - cx;

				// Por defecto llega hasta abajo
				let yEnd = canvas.height;

				// Si el escudo está activado y el rayo cae sobre la circunferencia (|dx| ≤ R)
				if (player.shieldLevel > 0 && Math.abs(dx) <= R) {
					// Altura de intersección: cy - √(R² - dx²)
					const deltaY = Math.sqrt(R * R - dx * dx);
					yEnd = shieldCY - deltaY;
				}

				ctx.strokeStyle = "red";
				ctx.lineWidth = 2;	//Ancho del rayo láser
				ctx.beginPath();
				ctx.moveTo(cx, topY);
				ctx.lineTo(cx, yEnd);
				ctx.stroke();
			});
		}

		function drawFractalShips() {
			fractalShips.forEach(s => {
				const shake = Math.sin(s.oscill) * 4;
				const xPos = s.x + shake;
				ctx.drawImage(fractalShipImage, xPos, s.y, s.w, s.h);

				// barra de vida
				ctx.fillStyle = "#444";
				ctx.fillRect(xPos, s.y - 8, s.w, 6);
				ctx.fillStyle = "red";
				ctx.fillRect(xPos, s.y - 8, s.w * (s.hp / s.hpIni), 6);
			});
		}

		function drawFractalBullets() {
			fractalBullets.forEach(b => {
				if (fractalProjectileImage.complete) {
					ctx.drawImage(fractalProjectileImage, b.x, b.y, b.size, b.size);
				} else {
					// fallback visual mientras carga
					ctx.fillStyle = "orange";
					ctx.fillRect(b.x, b.y, b.size, b.size);
				}
			});
		}

		function drawWaveSlices() {
			for (let i = waveSlices.length - 1; i >= 0; i--) {
				const w = waveSlices[i];
				w.age++;

				// aún no toca empezar
				if (w.age < w.delay) continue;

				// crece y avanza hacia abajo
				w.radius += w.expandSpeed;
				w.y += w.expandSpeed;

				// dibuja arco fijo, opacidad constante
				ctx.beginPath();
				ctx.arc(
					w.x, w.y,
					w.radius,
					w.startAngle,
					w.endAngle
				);
				ctx.lineWidth = w.thickness;
				ctx.strokeStyle = 'rgba(0, 200, 255, 1)';
				ctx.stroke();
			}
		}

		// Dibujar satélites cegadores
		function drawBlindSatellites() {
			blindSatellites.forEach(s => {
				ctx.drawImage(blindSatImage, s.x, s.y, s.size, s.size);
			});
		}

		function drawBlindWaves() {
			for (let i = blindWaves.length - 1; i >= 0; i--) {
				const w = blindWaves[i];

				// dibuja un anillo negro semitransparente
				ctx.save();
				ctx.beginPath();
				ctx.arc(w.x, w.y, w.radius, 0, 2 * Math.PI);
				ctx.strokeStyle = `rgba(0, 0, 0, ${w.alpha})`;
				ctx.lineWidth = w.thickness;
				ctx.stroke();
				ctx.restore();

				// actualiza expansión y atenuación
				w.radius += blindWaveSpeed;
				w.alpha = Math.max(0, w.alpha - w.fadeSpeed);
			}
		}

		function drawAbsorberSatellites() {
			absorberSatellites.forEach(s => {
				ctx.drawImage(absorberSatImage, s.x, s.y, s.size, s.size);
			});
		}

		function drawMirrorShip() {
			if (!mirrorShip) return;	//Sólo se dibuja si se ha creado alguna nave (si existe)

			ctx.drawImage(mirrorImage,
				mirrorShip.x, mirrorShip.y,
				mirrorShip.w, mirrorShip.h);

			// vida de la nave espejo
			const barWidth = mirrorShip.w;
			const barHeight = 6;
			const ratio = mirrorShip.hp / mirrorShip.hpIni;

			// fondo de la barra
			ctx.fillStyle = "#444";
			ctx.fillRect(
				mirrorShip.x,
				mirrorShip.y - barHeight - 4,
				barWidth,
				barHeight
			);

			// parte viva
			ctx.fillStyle = "lime";
			ctx.fillRect(
				mirrorShip.x,
				mirrorShip.y - barHeight - 4,
				barWidth * ratio,
				barHeight
			);

			// si tiene escudo se dibuja
			if (mirrorShip.shieldLevel > 0) {
				const colors = ["white", "blue", "red"];
				ctx.strokeStyle = colors[mirrorShip.shieldLevel - 1];
				ctx.lineWidth = 1 + mirrorShip.shieldLevel;
				ctx.beginPath();
				ctx.arc(
					mirrorShip.x + mirrorShip.w / 2,
					mirrorShip.y + mirrorShip.h / 2,
					mirrorShip.w / 2 + 10,
					0, Math.PI * 2
				);
				ctx.stroke();
			}

			//DEBUG qqq
			// const topY = mirrorShip.y;
			// const bottomY = mirrorShip.y + 2*mirrorShip.h;
			// ctx.strokeStyle = "red";
			// ctx.beginPath();
			// ctx.moveTo(0, topY);
			// ctx.lineTo(canvas.width, topY);
			// ctx.stroke();
			// ctx.strokeStyle = "blue";
			// ctx.beginPath();
			// ctx.moveTo(0, bottomY);
			// ctx.lineTo(canvas.width, bottomY);
			// ctx.stroke();
		}

		function drawMirrorBullets() {
			ctx.fillStyle = "orange";  // color distintivo
			for (let i = mirrorBullets.length - 1; i >= 0; i--) {
				const b = mirrorBullets[i];
				ctx.fillRect(b.x, b.y, 4, 10);
				b.y += bulletSpeed;

			}
		}


		function updateEnemyShooting() {
			const now = Date.now();
			enemies.forEach(e => {
				if (e.inBurst) {
					if (e.shotsFired < e.burstShots && now - e.lastShotTime >= 200) {
						enemyBullets.push({
							x: e.x + e.width / 2 - 2,
							y: e.y + e.height
						});
						e.shotsFired++;
						e.lastShotTime = now;
					}
					if (e.shotsFired >= e.burstShots) {
						e.inBurst = false;
						e.burstStart = now;
					}
				} else if (now - e.burstStart >= 2000) {
					e.inBurst = true;
					e.shotsFired = 0;
				}
			});
		}

		function updateLaserFiring() {
			const now = Date.now();
			laserShips.forEach(s => {
				if (s.waiting) return;

				if (s.laserOn) {
					// Apagar tras 3s
					if (now - s.laserStart >= 3000) {
						s.laserOn = false;
						s.lastShot = now;       // marca fin de rayo
					}
				} else {
					// Espera 2s tras fin antes de volver a disparar
					if (now - s.lastShot >= s.cooldown) {
						s.laserOn = true;
						s.laserStart = now;
					}
				}
			});
		}

		function updateFractalShooting() {
			const now = Date.now();
			fractalShips.forEach(s => {
				if (s.waiting) return;

				if (now - s.lastShot >= s.cooldown) {
					s.lastShot = now;
					// Bala madre
					fractalBullets.push({
						x: s.x + s.w / 2 - 4,
						y: s.y + s.h,
						size: 30,
						dx: 0,            // sin horizontal para la bala central
						dy: 4,
						splitAt: s.y + s.h + (canvas.height - (s.y + s.h)) * (0.1 + 0.8 * Math.random())
					});
					// Nuevo cooldown aleatorio
					s.cooldown = 1000 + 2000 * Math.random();
				}
			});
		}

		function updateFractalBullets() {
			for (let i = fractalBullets.length - 1; i >= 0; i--) {
				const b = fractalBullets[i];
				b.x += b.dx || 0;
				b.y += b.dy;
				// Si las balas salen fuera se eliminan
				if (b.y > canvas.height) {
					fractalBullets.splice(i, 1);
					continue;
				}
				// fragmentación de las balas
				if (typeof b.splitAt === 'number' && b.y >= b.splitAt) {// solo fragmentar si splitAt es un número válido
					if (b.y >= b.splitAt) {
						fractalBullets.splice(i, 1);
						// Tres fragmentos
						[0, -30, 30].forEach(angle => {
							const rad = angle * Math.PI / 180;
							const speed = 4;
							fractalBullets.push({
								x: b.x,
								y: b.y,
								size: 16,
								dx: speed * Math.sin(rad),
								dy: speed * Math.cos(rad),
								splitAt: null // estos NO volverán a fragmentarse
							});
						});
						continue;
					}
				}
			}
		}

		function updateWaveShooting() {
			// Disparar ondas paralizantes con cierta probabilidad
			satellites.forEach(s => {
				if (Math.random() < s.probShot) {
					const cx = s.x + s.size / 2;
					const cy = s.y + s.size;
					// 3 ondas en ráfaga, escalonadas 8 frames (~0.13 s)
					for (let i = 0; i < 3; i++) {
						spawnWaveSlice(cx, cy, i * 8);
					}
				}
			});
		}

		function updateBlindWave() {
			const now = Date.now();

			blindSatellites.forEach(s => {
				if (now >= s.nextWaveTime) {
					// centro de la futura onda
					const cx = s.x + s.size / 2;
					const cy = s.y + s.size / 2;

					// distancia máxima a una esquina del canvas (se calcula para saber 
					// cuándo sale de pantalla y poder eliminarla)
					const dists = [
						Math.hypot(cx, cy),                             // esquina (0,0)
						Math.hypot(canvas.width - cx, cy),              // (w,0)
						Math.hypot(cx, canvas.height - cy),             // (0,h)
						Math.hypot(canvas.width - cx, canvas.height - cy) // (w,h)
					];
					const maxDist = Math.max(...dists);

					// crea la onda cegadora asociada
					blindWaves.push({
						x: cx,
						y: cy,
						radius: 0,
						maxRadius: Math.hypot(canvas.width, canvas.height),
						thickness: 500,          // grosor del anillo
						alpha: 1,               // opacidad inicial
						fadeSpeed: 0,        // cuánto decrementa la alpha por frame
						maxDist
					});

					// programa el siguiente disparo
					let tmin = 4000;
					let tmax = 6000;
					s.nextWaveTime = now + + tmin + Math.random() * (tmax - tmin);
				}
			});
		}

		function updateMirrorShooting() {
			if (!mirrorShip) return;	//Si no existe la nave

			const now = Date.now();
			const grade = SHOT_GRADES[shotGrade];
			if (now - mirrorLastShot < grade.cooldown) return;
			mirrorLastShot = now;

			// genera balas idénticas a las del jugador
			const type = grade.type;
			const baseX = mirrorShip.x + mirrorShip.w / 2;
			const y0 = mirrorShip.y + mirrorShip.h;

			if (type === "simple") {
				mirrorBullets.push({ x: baseX - 2, y: y0 });
			}
			else if (type === "double") {
				mirrorBullets.push({ x: baseX - 6, y: y0 });
				mirrorBullets.push({ x: baseX + 2, y: y0 });
			}
			else if (type === "quadruple") {
				const offsets = [-23, -6, +2, +20];
				offsets.forEach(off => mirrorBullets.push({ x: baseX + off, y: y0 }));
			}
		}




		// ===== Quiz =====
		function startQuiz(origin) {
			quizOrigin = origin;
			let a = 1 + Math.floor(Math.random() * 9),
				b = 1 + Math.floor(Math.random() * 9),
				c = a * b;

			quizOptions = [];
			if (origin === "shield") {
				// Preguntamos el factor faltante
				//quizQuestion = `¿Qué número × ${a} = ${c}?`;
				quizQuestion = `¿Qué número falta?<br><strong>? × ${a} = ${c}</strong>`;
				// posición de la respuesta correcta
				quizIdx = Math.floor(Math.random() * 3);

				for (let i = 0; i < 3; i++) {
					if (i === quizIdx) {
						quizOptions.push(b);
					} else {
						let w;
						do { w = 1 + Math.floor(Math.random() * 9); }
						while (w === b || quizOptions.includes(w));
						quizOptions.push(w);
					}
				}
			} else {
				// Lógica anterior (multiplicación completa)
				quizQuestion = `¿Cuánto es?<br><strong>${a} × ${b}</strong>`;
				quizIdx = Math.floor(Math.random() * 3);
				for (let i = 0; i < 3; i++) {
					if (i === quizIdx) quizOptions.push(c);
					else {
						let w;
						do { w = c + (Math.floor(Math.random() * 11) - 5); }
						while (w === c || quizOptions.includes(w));
						quizOptions.push(w);
					}
				}
			}

			// Mostrar overlay…
			document.getElementById("quizOverlay").style.display = "flex";
			document.getElementById("quizQuestion").innerHTML = quizQuestion;
			quizOptions.forEach((opt, i) => {
				document.getElementById(`option${i}`).textContent =
					(i === 0 ? "⬅️" : i === 1 ? "⬆️" : "➡️") + " " + opt;
			});
			quizStart = Date.now();
			quizAnswered = false;
			quizActive = true;
			quizLoop();
		}

		function endQuiz(correct) {
			if (quizAnswered) return;
			quizAnswered = true;
			quizActive = false;
			document.getElementById("quizOverlay").style.display = "none";

			if (quizOrigin === "shield") {	//Pregunta de bonus de escudo
				if (correct) {
					quizCorrects++;

					// Ajusta el escudo de la nave Espejo
					if (mirrorShip && mirrorShip.shieldLevel < 3) {
						mirrorShip.shieldLevel++;
					}

					// Ajusta el escudo de la nave del jugador
					if (player.shieldLevel < 3) {
						player.shieldLevel++;
					} else {
						score += POINTS.shield;
						popups.push({
							x: player.x + player.w / 2,
							y: player.y,
							text: `+${POINTS.shield}`,
							alpha: 1
						});
					}
				} else {
					quizFails++;
				}
			} else {	//Pregunta de bonus de disparo
				if (correct) {
					quizCorrects++;
					const maxGrade = maxGradeForLevel(currentLevel);
					if (shotGrade < maxGrade) {
						shotGrade++;
					} else {
						score += POINTS.bonus
						popups.push({
							x: player.x + player.w / 2,
							y: player.y,
							text: '+' + POINTS.bonus,
							alpha: 1
						});
					}
				} else {
					quizFails++;
				}
			}

			//requestAnimationFrame(gameLoop);
		}

		function quizLoop() {
			if (!quizActive) return;

			const rem = 3 - Math.floor((Date.now() - quizStart) / 1000);
			document.getElementById("quizTimer").textContent = `Tiempo: ${rem}s`;

			if (rem <= 0) { endQuiz(false); return; }

			requestAnimationFrame(quizLoop);
		}

		// ===== Colisiones =====
		function checkCollisions() {
			// Balas del jugador
			bullets.forEach((b, bi) => {
				// contra rocas
				rocks.forEach((r, ri) => {
					if (b.x < r.x + r.size && b.x + 4 > r.x &&
						b.y < r.y + r.size && b.y + 10 > r.y) {
						bullets.splice(bi, 1);
						r.hp--;
						if (r.hp <= 0) {
							score += r.strong ? POINTS.strongRock : POINTS.rock;
							// Explosión en la roca
							explosions.push({
								x: r.x + r.size / 2,
								y: r.y + r.size / 2,
								radius: 0,
								maxRadius: r.strong ? 40 : 30,
								alpha: 1
							});
							//Texto con los puntos conseguidos
							popups.push({
								x: r.x + r.size / 2,
								y: r.y,
								text: '+' + (r.strong ? POINTS.strongRock : POINTS.rock),
								alpha: 1
							});
							rocks.splice(ri, 1);//Eliminar instacia de roca

							// Sonido de explosión
							if (!muted) {
								playExplosionSound();
							}
						}
					}
				});

				// contra naves enemigas básicas
				for (let ei = enemies.length - 1; ei >= 0; ei--) {
					const e = enemies[ei];
					if (
						b.x < e.x + e.width &&
						b.x + 4 > e.x &&
						b.y < e.y + e.height &&
						b.y + 10 > e.y
					) {
						bullets.splice(bi, 1);
						e.hp--;
						e.oscill = Math.random() * 10; // temblor
						if (e.hp <= 0) {
							enemies.splice(ei, 1);
							score += POINTS.basicEnemy;


							// Sonido de explosión
							if (!muted) {
								playExplosionShipSound();
							}

							// Efecto explosión
							explosions.push({
								x: e.x + e.width / 2,
								y: e.y + e.height / 2,
								radius: 0,
								maxRadius: 40,
								alpha: 1
							});
							popups.push({
								x: e.x + e.width / 2,
								y: e.y,
								text: '+' + POINTS.basicEnemy,
								alpha: 1
							});

							//Hace aparecer otra nave para reemplazar la sustituida

							if (isInfiniteMode) { // Modo infinito
								nextShipSpawnTime = Date.now() + 2000;
							} else { // Modo campaña
								if (Math.random() < 0.5) {
									spawnEnemy("left");
								} else {
									spawnEnemy("right");
								}
							}
						}
						break;
					}
				}

				//Contra naves láser
				for (let li = laserShips.length - 1; li >= 0; li--) {
					const s = laserShips[li];
					if (b.x < s.x + s.w && b.x + 4 > s.x && b.y < s.y + s.h && b.y + 10 > s.y) {
						bullets.splice(bi, 1);
						s.hp--;
						s.oscill = 10;
						if (s.hp <= 0) {
							laserShips.splice(li, 1);
							score += POINTS.laser;

							// Sonido de explosión
							if (!muted) {
								playExplosionShipSound();
							}

							// Efecto explosión
							explosions.push({
								x: s.x + s.w / 2,
								y: s.y + s.h / 2,
								radius: 0,
								maxRadius: 40,
								alpha: 1
							});

							// Puntos en pantalla
							popups.push({
								x: s.x + s.w / 2,
								y: s.y,
								text: "+" + POINTS.laser,
								alpha: 1
							});

							if (isInfiniteMode) { nextShipSpawnTime = Date.now() + 2000; }
						}
						break;
					}
				}

				//Contra naves fractales
				for (let li = fractalShips.length - 1; li >= 0; li--) {
					const s = fractalShips[li];
					if (b.x < s.x + s.w && b.x + 4 > s.x && b.y < s.y + s.h && b.y + 10 > s.y) {
						bullets.splice(bi, 1);
						s.hp--;
						s.oscill = 10;
						if (s.hp <= 0) {
							fractalShips.splice(li, 1);
							score += POINTS.fractal;

							// Sonido de explosión
							if (!muted) {
								playExplosionShipSound();
							}

							// Efecto explosión
							explosions.push({
								x: s.x + s.w / 2,
								y: s.y + s.h / 2,
								radius: 0,
								maxRadius: 40,
								alpha: 1
							});

							// Puntos por pantalla
							popups.push({
								x: s.x + s.w / 2,
								y: s.y,
								text: "+" + POINTS.fractal,
								alpha: 1
							});

							if (isInfiniteMode) { nextShipSpawnTime = Date.now() + 2000; }
						}
						break;
					}
				}

				// Contra la nave espejo
				if (mirrorShip) {
					if (
						b.x < mirrorShip.x + mirrorShip.w &&
						b.x + 4 > mirrorShip.x &&
						b.y < mirrorShip.y + mirrorShip.h &&
						b.y + 10 > mirrorShip.y
					) {
						// eliminar bala
						bullets.splice(bi, 1);

						// si hay escudo, resta un nivel
						if (mirrorShip.shieldLevel > 0) {
							mirrorShip.shieldLevel--;
						} else {
							// resta vida
							mirrorShip.hp--;
						}

						// chequeo de destrucción
						if (mirrorShip.hp <= 0) {
							mirrorDefeated = true	// Aviso de que la nave ha sido eliminada

							// Sonido de explosión
							if (!muted) {
								playExplosionShipSound();
							}

							// puntuación por pantalla
							score += POINTS.mirror;
							popups.push({
								x: mirrorShip.x + mirrorShip.w / 2,
								y: mirrorShip.y,
								text: "+" + POINTS.mirror,
								alpha: 1
							});
							// Efecto de explosión
							explosions.push({
								x: mirrorShip.x + mirrorShip.w / 2,
								y: mirrorShip.y + mirrorShip.h / 2,
								radius: 0,
								maxRadius: 60,
								alpha: 1
							});
							// eliminar la nave espejo
							mirrorShip = null;
						}
					}
				}

				//Contra cometas
				comets.forEach((c, ci) => {
					if (
						b.x < c.x + c.size &&
						b.x + 4 > c.x &&
						b.y < c.y + c.size &&
						b.y + 10 > c.y
					) {
						bullets.splice(bi, 1);
						c.hp--;
						if (c.hp <= 0) {
							score += POINTS.comet;

							// Sonido de explosión
							if (!muted) {
								playExplosionSound();
							}

							// Explosión del cometa
							explosions.push({
								x: c.x + c.size / 2,
								y: c.y + c.size / 2,
								radius: 0,
								maxRadius: 30,
								alpha: 1
							});

							//Texto con los puntos conseguidos
							popups.push({
								x: c.x + c.size / 2,
								y: c.y,
								text: '+' + POINTS.comet,
								alpha: 1
							});
							comets.splice(ci, 1);
						}
					}
				});

				//Contra satélites paralizadores
				satellites.forEach((s, si) => {
					if (
						b.x < s.x + s.size && b.x + 4 > s.x &&
						b.y < s.y + s.size && b.y + 10 > s.y
					) {
						bullets.splice(bi, 1);
						s.hp--;
						if (s.hp <= 0) {
							satellites.splice(si, 1);
							score += POINTS.satellite;

							// Sonido de explosión
							if (!muted) {
								playExplosionSatelliteSound();
							}

							// Efecto explosión
							explosions.push({
								x: s.x + s.size / 2,
								y: s.y + s.size / 2,
								radius: 0,
								maxRadius: 20,
								alpha: 1
							});

							// Texto por pantalla
							popups.push({
								x: s.x + s.size / 2,
								y: s.y,
								text: "+" + POINTS.satellite,
								alpha: 1
							});

							if (isInfiniteMode) { nextSatelliteSpawnTime = Date.now() + 3000; }
						}
					}
				});

				// contra satélites cegadores
				blindSatellites.forEach((s, si) => {
					if (
						b.x < s.x + s.size && b.x + 4 > s.x &&
						b.y < s.y + s.size && b.y + 10 > s.y
					) {
						bullets.splice(bi, 1);
						blindSatellites.splice(si, 1);
						score += POINTS.satellite;

						// Sonido de explosión
						if (!muted) {
							playExplosionSatelliteSound();
						}

						// Efecto explosión
						explosions.push({
							x: s.x + s.size / 2,
							y: s.y + s.size / 2,
							radius: 0,
							maxRadius: 20,
							alpha: 1
						});

						// Puntos por pantalla
						popups.push({
							x: s.x + s.size / 2,
							y: s.y,
							text: "+" + POINTS.satellite,
							alpha: 1
						});

						if (isInfiniteMode) { nextSatelliteSpawnTime = Date.now() + 3000; }
					}
				});

				// Contra satélite absorvedor
				absorberSatellites.forEach((s, si) => {
					if (
						b.x < s.x + s.size &&
						b.x + 4 > s.x &&
						b.y < s.y + s.size &&
						b.y + 10 > s.y
					) {
						bullets.splice(bi, 1); // la bala desaparece
					}
				});
			});

			// bonuses de disparo
			bonuses.forEach((b, bi) => {
				if (b.x < player.x + player.w && b.x + b.size > player.x &&
					b.y < player.y + player.h && b.y + b.size > player.y) {
					bonuses.splice(bi, 1);
					startQuiz("disparo");
				}
			});

			// powerUps (Vidas)
			powerUps.forEach((p, pi) => {
				if (p.x < player.x + player.w && p.x + p.size > player.x &&
					p.y < player.y + player.h && p.y + p.size > player.y) {
					powerUps.splice(pi, 1);

					//Si estamos en en nivel final (permite tener más vidas de lo normal)
					if (currentLevel === 10) {//Nivel 11 (enemigo final)
						if (lives < maxLives) {
							lives++;
							updateLivesDisplay();
						} else if (extraLives < 3) {
							extraLives++;
							updateLivesDisplay();
						} else {
							score += POINTS.powerUp;
							//Texto con los puntos conseguidos por pantalla
							popups.push({
								x: p.x,
								y: p.y,
								text: '+' + POINTS.powerUp,
								alpha: 1
							});
						}
					} else { //Todos los niveles menos el final
						if (lives < maxLives) {
							lives++;
							updateLivesDisplay();
						} else {
							score += POINTS.powerUp;
							//Texto con los puntos conseguidos por pantalla
							popups.push({
								x: p.x,
								y: p.y,
								text: '+' + POINTS.powerUp,
								alpha: 1
							});
						}
					}

				}
			});

			// colisión rocas contra jugador
			for (let i = rocks.length - 1; i >= 0; i--) {
				const r = rocks[i];
				if (
					r.x < player.x + player.w &&
					r.x + r.size > player.x &&
					r.y < player.y + player.h &&
					r.y + r.size > player.y
				) {
					if (player.shieldLevel > 0) {
						player.shieldLevel--;
					} else {
						explosions.push({
							x: player.x + player.w / 2,
							y: player.y + player.h / 2,
							radius: 0,
							maxRadius: 40,
							alpha: 1
						});
						loseLife();
						shotGrade = 0;
					}
					rocks.splice(i, 1);
					break;
				}
			}

			// Bonus de escudo contra jugador
			shieldBonuses.forEach((s, si) => {
				if (
					s.x < player.x + player.w &&
					s.x + s.size > player.x &&
					s.y < player.y + player.h &&
					s.y + s.size > player.y
				) {
					shieldBonuses.splice(si, 1);
					startQuiz("shield");
				}
			});

			// Balas naves enemigas básicas contra jugador
			for (let i = enemyBullets.length - 1; i >= 0; i--) {
				const b = enemyBullets[i];
				const now = Date.now();

				const hitPlayer =
					b.x < player.x + player.w &&
					b.x + 4 > player.x &&
					b.y < player.y + player.h &&
					b.y + 10 > player.y;

				if (!hitPlayer) continue;

				// Eliminamos siempre la bala
				enemyBullets.splice(i, 1);

				// Si tenemos escudo, rompemos un nivel sin daño extra
				if (player.shieldLevel > 0) {
					player.shieldLevel--;
					updateHUD();      // refresca la info de escudo en pantalla
				}

				// Si no hay escudo y no estamos invencibles, restamos vida
				else if (now - player.lastHitTime > player.invincibleTime) {
					player.lastHitTime = now;
					player.flashTime = now;   // parpadeo
					loseLife();
					updateLivesDisplay();
				}
			}

			//Colisión de láser con jugador
			laserShips.forEach(s => {
				const now = Date.now();

				if (!s.laserOn) return;

				// centro X del haz y Y de salida
				const cx = s.x + s.w / 2;
				const topY = s.y + s.h;

				// parámetros del escudo
				const shieldCX = player.x + player.w / 2;
				const shieldCY = player.y + player.h / 2;
				const R = player.w / 2 + 10;

				// distancia horizontal al centro del escudo
				const dx = shieldCX - cx;

				// Si existe escudo y el haz toca el escudo
				if (player.shieldLevel > 0 && Math.abs(dx) <= R) {
					// Si acaba de empezar a recibir láser, marcamos la hora
					if (player.shieldTouchStart === 0) {
						player.shieldTouchStart = now;
					}
					// Si lleva mucho tiempo recibiendo láser, quitamos 1 nivel de escudo
					else if (now - player.shieldTouchStart >= 500) {
						player.shieldLevel--;
						player.shieldTouchStart = now;  // reiniciamos el conteo para el siguiente nivel
						updateHUD();
					}
					return;  // no hacemos daño al jugador (el escudo lo ha bloqueado)
				}

				// Si el haz NO está tocando el escudo, reseteamos el temporizador
				player.shieldTouchStart = 0;

				// Si el haz no toca un escudo, verificamos colisión real con la nave
				const laserHitsPlayer =
					cx >= player.x &&
					cx <= player.x + player.w &&
					topY <= player.y + player.h;

				if (laserHitsPlayer && now - player.lastHitTime > player.invincibleTime) {
					player.lastHitTime = now;
					player.flashTime = now;       // parpadeo
					if (player.shieldLevel > 0) {
						player.shieldLevel--;
					} else {
						loseLife();
						updateLivesDisplay();
					}
				}
			});

			//Balas fragmentarias contra jugador
			fractalBullets.forEach((b, i) => {
				if (b.x < player.x + player.w && b.x + b.size > player.x &&
					b.y < player.y + player.h && b.y + b.size > player.y) {
					fractalBullets.splice(i, 1);
					if (player.shieldLevel > 0) {
						player.shieldLevel--;
					} else if (Date.now() - player.lastHitTime > player.invincibleTime) {
						player.lastHitTime = Date.now();
						loseLife();
						updateLivesDisplay();
					}
				}
			});

			//Cometas contra jugador
			comets.forEach((c, ci) => {
				if (
					c.x < player.x + player.w &&
					c.x + c.size > player.x &&
					c.y < player.y + player.h &&
					c.y + c.size > player.y
				) {
					comets.splice(ci, 1);
					if (player.shieldLevel > 0) {
						player.shieldLevel--;
					} else {
						loseLife();
						updateLivesDisplay();
					}
				}
			});

			// Ondas paralizadoras contra jugador
			waveSlices.forEach(slice => {
				// muestreamos N puntos sobre el arco para comprobar
				const segments = 8;
				const angleStep = (slice.endAngle - slice.startAngle) / segments;

				for (let i = 0; i <= segments; i++) {
					const angle = slice.startAngle + i * angleStep;
					const px = slice.x + slice.radius * Math.cos(angle);
					const py = slice.y + slice.radius * Math.sin(angle);

					// chequeo AABB contra jugador
					if (
						px >= player.x &&
						px <= player.x + player.w &&
						py >= player.y &&
						py <= player.y + player.h
					) {
						// aplicamos parálisis 3s sin distinguir escudo
						player.paralyzeEnd = Date.now() + 3000;
						// salimos del bucle de puntos para esta slice
						break;
					}
				}
			});

			// ——— Balas de la nave Espejo contra jugador ———
			mirrorBullets.forEach((b, i) => {
				if (
					b.x < player.x + player.w &&
					b.x + 4 > player.x &&
					b.y < player.y + player.h &&
					b.y + 10 > player.y
				) {
					// destruye bala
					mirrorBullets.splice(i, 1);

					// primero consume el escudo si lo tienes
					if (player.shieldLevel > 0) {
						player.shieldLevel--;
						updateHUD();
					} else {
						// de lo contrario, resta vida
						if (Date.now() - player.lastHitTime > player.invincibleTime) {
							player.lastHitTime = Date.now();
							loseLife();
							updateLivesDisplay();
						}
					}
				}
			});

		}

		// ===== Movimiento jugador =====
		const keys = {};
		document.addEventListener("keydown", e => {
			if (quizActive) {
				let sel = null;
				if (e.code === "ArrowLeft") sel = 0;
				if (e.code === "ArrowUp") sel = 1;
				if (e.code === "ArrowRight") sel = 2;
				if (sel !== null) endQuiz(sel === quizIdx);
				return;
			}

			if (e.code === "KeyP") paused = !paused;

			if (e.code === "KeyM") {
				muted = !muted;
				updateMuteIcon();
				if (!muted) {
					bgMusic.play();
				} else {
					bgMusic.pause();
				}
				btnSoundMenu.textContent = muted ? "Sonido OFF" : "Sonido ON";
			}


			// DEBUG:-----------------
			if (e.code === "KeyQ") {// Comprueba si se ha pulsado la tecla "Q" 3 veces para activar "cheats"
				const now = Date.now();

				// Resetea el contador si ha pasado más de 1 segundo desde la última vez
				if (now - lastQPressTime > 1000) {
					qPressCount = 0;
				}

				// Incrementa el contador y actualiza el tiempo
				qPressCount++;
				lastQPressTime = now;

				// Si el contador llega a 3, muestra el mensaje y resetea
				if (qPressCount === 3) {
					debugMode = !debugMode

					//const debugIcon = document.getElementById("debugIcon");
					if (debugMode) {
						debugIcon.classList.remove("hidden");
					} else {
						debugIcon.classList.add("hidden");
					}
				}
			} else {
				// Si se pulsa cualquier otra tecla, se rompe la secuencia
				qPressCount = 0;
			}

			if (e.code === "KeyD") {
				if (debugMode) {
					shotGrade = 4;
				}
			}
			if (e.code === "KeyE") {
				if (debugMode) {
					player.shieldLevel = 3;
				}
			}
			if (e.code === "KeyL" && currentLevel < 10) {
				if (debugMode) {
					// Limpia entidades
					resetEntities();

					// Avanza de nivel
					currentLevel++;
					score = 0;
					scoreGoal = levels[currentLevel].goal;
					updateHUD();
					showLevelOverlay();
				}
			};

			if (e.code === "KeyI") {
				if (debugMode) {
					inmortal = !inmortal;
				}
			};
			// -------------------------

			keys[e.code] = true;
		});

		document.addEventListener("keyup", e => {
			keys[e.code] = false;
		});

		function movePlayer() {
			const now = Date.now();

			// Solo mover si no está paralizado
			if (now > player.paralyzeEnd) {
				if (keys["ArrowLeft"] && player.x > 0) {
					player.x -= player.speed;
				}
				if (keys["ArrowRight"] && player.x < canvas.width - player.w) {
					player.x += player.speed;
				}
			}

			if (keys["Space"] && Date.now() - lastShotTime > SHOT_GRADES[shotGrade].cooldown) {
				lastShotTime = Date.now();
				const type = SHOT_GRADES[shotGrade].type;
				if (type === "simple") {
					bullets.push({ x: player.x + player.w / 2 - 2, y: player.y });
				} else if (type === "double") {
					bullets.push({ x: player.x + player.w / 2 - 6, y: player.y });
					bullets.push({ x: player.x + player.w / 2 + 2, y: player.y });
				} else if (type === "quadruple") {
					// calcula el centro horizontal de la nave
					const midX = player.x + player.w / 2;
					// offsets para las 4 líneas, separadas simétricamente
					const offsets = [-23, -6, +2, +20];
					offsets.forEach(off => {
						bullets.push({ x: midX + off, y: player.y });
					});
				}
				// Reproducir sonido disparo
				if (!muted) {
					shotSound.volume = 0.2;  // entre 0 (silencio) y 1 (volumen total)
					shotSound.currentTime = 0;	//Pone el sonido desde el principio (Por si disparas mientras ya está sonando uno)
					shotSound.play();
				}

			}
		}

		//Naves enemigas básicas
		function moveEnemies() {
			const now = Date.now();
			enemies.forEach(e => {
				if (e.waiting) {
					if (now - e.spawnTime >= 2000) {
						e.waiting = false; // empieza a moverse
					}
					return; // no se mueve aún
				}

				if (e.entering) {
					if ((e.dx > 0 && e.x < e.targetX) || (e.dx < 0 && e.x > e.targetX)) {
						e.x += e.dx;
					} else {
						e.x = e.targetX;
						e.entering = false;
						e.inBurst = true;
						e.dx = 2;
					}
				} else {
					e.x += e.dx;
					if (e.x < 0 || e.x > canvas.width - e.width) e.dx *= -1;
				}
				e.oscill *= 0.9;
			});
		}

		// Náves láser
		function moveLaserShips() {
			const now = Date.now();
			laserShips.forEach(s => {
				if (s.waiting && now - s.spawnTime < 2000) return;
				s.waiting = false;

				// entrada o patrulla
				if (s.entering) {//Entrada
					if ((s.dx > 0 && s.x < s.targetX) || (s.dx < 0 && s.x > s.targetX)) {
						s.x += s.dx;
					} else {
						s.entering = false; s.dx = 2;
					}
				} else {//Patrulla
					s.x += s.dx;
					if (s.x < 0 || s.x > canvas.width - s.w) s.dx *= -1;
				}

				// atenúa el temblor poco a poco
				s.oscill *= 0.9;
			});
		}

		function moveFractalShips() {
			fractalShips.forEach(s => {
				const now = Date.now();
				// 2s de espera al spawnear
				if (s.waiting && now - s.spawnTime < 2000) return;
				s.waiting = false;

				// Entrada: mueve hasta targetX (igual que el laser), o patrulla
				if (s.entering) {
					if ((s.dx > 0 && s.x < s.targetX) || (s.dx < 0 && s.x > s.targetX)) {
						s.x += s.dx;
					} else {
						s.x = s.targetX;
						s.entering = false;
						s.dx = 2;
					}
				} else {// Patrulla horizontal
					s.x += s.dx;
					if (s.x < 0 || s.x + s.w > canvas.width) s.dx *= -1;
				}
				s.oscill *= 0.9;// Degrada temblor
			});
		}

		function moveSatellite() {
			// actualiza posición de cada satélite paralizador
			satellites.forEach(s => s.x += s.dx);
		}

		function moveBlindSatellites() {
			// actualiza posición de cada satélite cegador
			blindSatellites.forEach(s => s.x += s.dx);
		}

		function moveAbsorberSatellites() {
			absorberSatellites.forEach(s => s.x += s.dx);
		}

		function moveMirrorShip() {
			if (!mirrorShip) return;

			// Movimiento horizontal básico
			mirrorShip.x += mirrorShip.vx;

			// Rebote en los bordes de la pantalla
			if (mirrorShip.x <= 0) {
				mirrorShip.x = 0;
				mirrorShip.vx *= -1;
			} else if (mirrorShip.x + mirrorShip.w >= canvas.width) {
				mirrorShip.x = canvas.width - mirrorShip.w;
				mirrorShip.vx *= -1;
			}

			// Detección de balas del jugador para esquivarlas
			for (let b of bullets) {
				// Se esquivan sólo las balas que están entre las alturas del culo de la
				// nave Espejo y la punta de la nave (si fuera el doble de larga)
				if (b.y < mirrorShip.y + 2 * mirrorShip.h && b.y > mirrorShip.y) {//qqq
					const mx = mirrorShip.x + mirrorShip.w / 2;   // centro de la Espejo
					const bx = b.x + 2;                         // centro aproximado de la bala
					const dx = bx - mx;

					if (Math.abs(dx) < mirrorShip.evadeThreshold) {
						// si la bala viene por la derecha, se mueve a la izquierda, y viceversa
						mirrorShip.vx = dx > 0
							? -Math.abs(mirrorShip.vx)
							: Math.abs(mirrorShip.vx);
						break;
					}
				}
			}
		}



		// ===== Pantallas de fin de juego =====
		function showGameOver() {
			gameRunning = false;
			lastGameWasInfinite = isInfiniteMode;	//Si se ha perdido jugando al modo campaña o al modo infinito
			captureLastRun();	// Graba los resultados de esta partida
			if (isInfiniteMode) {
				checkInfiniteRecords(); // Comprueba récords del modo infinito
			} else {
				checkRecords(); // Comprueba récords del modo campaña
			}
			checkAchivements();	// Comprueba si se ha obtenido algún logro
			actualizarMedallas();	//Mostrar las medallas (logros) conseguidas

			//Datos por pantalla:
			document.getElementById("endStats").textContent = `Aciertos: ${quizCorrects} | Fallos: ${quizFails}`;
			document.getElementById("gameOverScreen").style.display = "flex";
			document.getElementById("ver-logros").onclick = () => { showAchievements(); };
		}

		function showWin() {
			gameRunning = false;
			captureLastRun();	// Graba los resultados de esta partida
			if (isInfiniteMode) {
				checkInfiniteRecords(); // Comprueba récords del modo infinito
			} else {
				localStorage.setItem("campaignCompleted", "true");
				btnPlayInfinite.disabled = false;	// Reactivar botón
				refreshInfiniteButton();

				checkRecords(); // Comprueba récords del modo campaña
			}
			checkAchivements();	// Comprueba si se ha obtenido algún logro
			actualizarMedallas();	//Mostrar las medallas (logros) conseguidas

			//Datos por pantalla:
			document.getElementById("endStatsWin").textContent = `Aciertos: ${quizCorrects} | Fallos: ${quizFails}`;
			document.getElementById("winScreen").classList.add("win");
			document.getElementById("winScreen").style.display = "flex";
			document.getElementById("ver-logros-victoria").onclick = () => { showAchievements(); };

			startCelebration();
		}

		function resizeCanvas() {
			confettiCanvas.width = canvas.width;
			confettiCanvas.height = canvas.height;
		}
		window.addEventListener("resize", resizeCanvas);

		function spawnConfetti() {
			const x = Math.random() * confettiCanvas.width;
			confettiParticles.push({
				x, y: -10,
				vx: (Math.random() - 0.5) * 2,
				vy: 2 + Math.random() * 3,
				size: 5 + Math.random() * 5,
				color: `hsl(${Math.random() * 360},80%,60%)`,
				rot: Math.random() * Math.PI * 2,
				drot: (Math.random() - 0.5) * 0.2
			});
		}

		function drawConfetti() {
			confCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
			confettiParticles.forEach((p, i) => {
				p.x += p.vx; p.y += p.vy; p.rot += p.drot;
				confCtx.save();
				confCtx.translate(p.x, p.y);
				confCtx.rotate(p.rot);
				confCtx.fillStyle = p.color;
				confCtx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
				confCtx.restore();
				if (p.y > confettiCanvas.height + 20) confettiParticles.splice(i, 1);
			});
		}

		// Fuegos artificiales: ráfagas de partículas radiales
		let fireworks = [];
		function spawnFirework() {
			const cx = Math.random() * confettiCanvas.width;
			const cy = Math.random() * confettiCanvas.height / 2;
			const count = 30 + Math.random() * 20;
			const hue = Math.random() * 360;
			for (let i = 0; i < count; i++) {
				const angle = (i / count) * Math.PI * 2;
				fireworks.push({
					x: cx, y: cy,
					vx: Math.cos(angle) * (2 + Math.random() * 3),
					vy: Math.sin(angle) * (2 + Math.random() * 3),
					alpha: 1,
					hue
				});
			}
		}

		function drawFireworks() {
			fireworks.forEach((f, i) => {
				f.x += f.vx; f.y += f.vy; f.alpha -= 0.02;
				if (f.alpha <= 0) return fireworks.splice(i, 1);
				confCtx.fillStyle = `hsla(${f.hue},80%,70%,${f.alpha})`;
				confCtx.beginPath();
				confCtx.arc(f.x, f.y, 2 + Math.random() * 2, 0, Math.PI * 2);
				confCtx.fill();
			});
		}


		function celebrationLoop() {
			drawConfetti();
			drawFireworks();
			if (Math.random() < 0.1) spawnFirework();
			if (confettiParticles.length < 200 && Math.random() < 0.3) spawnConfetti();
			celebrationLoopId = requestAnimationFrame(celebrationLoop);
		}

		function startCelebration() {
			resizeCanvas();
			confettiCanvas.style.display = "block";
			victoryMusic.currentTime = 0;
			victoryMusic.play();
			for (let i = 0; i < 200; i++) spawnConfetti();
			spawnFirework();
			celebrationLoop();
		}

		function stopCelebration() {
			cancelAnimationFrame(celebrationLoopId);
			confettiCanvas.style.display = "none";
			fireworks = [];
			confettiParticles = [];
			victoryMusic.pause();
		}

		function restartGame() {
			// Reset variables 
			resetBasicVariables();

			if (lastGameWasInfinite) {
				// Configuración para reiniciar en MODO INFINITO
				isInfiniteMode = true;
				currentLevel = levels.length - 1; // Apunta al último nivel (el infinito)
				scoreGoal = Infinity;
			} else {
				// Configuración para reiniciar en MODO CAMPAÑA 
				isInfiniteMode = false;
				currentLevel = 0;
				scoreGoal = levels[0].goal;
			}

			// Reiniciar estado del jugador
			resetPlayer();

			// Limpieza de entidades
			resetEntities();

			// Ocultar pantallas de fin
			document.getElementById("gameOverScreen").style.display = "none";
			document.getElementById("winScreen").style.display = "none";

			// Limpia la celebración de ganar el juego
			stopCelebration();
			document.getElementById("winScreen").style.display = "none";

			updateLivesDisplay();
			updateHUD();
			showLevelOverlay();
			gameLoop();
		}

		function resetPlayer() {
			// Posición central inferior
			player.x = canvas.width / 2 - player.w / 2;
			player.y = canvas.height - player.h - 20;
			// Estado de escudo e invencibilidad
			player.shieldLevel = 0;
			player.lastHitTime = 0;
			player.shieldTouchStart = 0;
			// invencibilidad
			player.flashTime = 0;
			// Parálisis
			player.paralyzeEnd = 0;

		}

		document.getElementById("restartBtn").onclick = restartGame;
		document.getElementById("restartWinBtn").onclick = restartGame;


		//Limpieza entidades que salen de la pantalla
		function cleanEntities() {
			// Balas fuera de pantalla
			for (let i = bullets.length - 1; i >= 0; i--) {
				if (bullets[i].y < -10) bullets.splice(i, 1);
			}

			// Balas enemigas fuera de pantalla
			for (let i = enemyBullets.length - 1; i >= 0; i--) {
				if (enemyBullets[i].y > canvas.height) enemyBullets.splice(i, 1);
			}

			// Rocas fuera de pantalla 
			for (let i = rocks.length - 1; i >= 0; i--) {
				if (rocks[i].y > canvas.height) rocks.splice(i, 1);
			}

			// Cometas fuera de pantalla 
			for (let i = comets.length - 1; i >= 0; i--) {
				if (comets[i].y > canvas.height) comets.splice(i, 1);
			}

			// Bonus de disparo fuera de pantalla
			for (let i = bonuses.length - 1; i >= 0; i--) {
				if (bonuses[i].y > canvas.height) bonuses.splice(i, 1);
			}

			// PowerUps (vidas) fuera de pantalla
			for (let i = powerUps.length - 1; i >= 0; i--) {
				if (powerUps[i].y > canvas.height) powerUps.splice(i, 1);
			}

			// Bonus de escudo fuera de pantalla
			for (let i = shieldBonuses.length - 1; i >= 0; i--) {
				if (shieldBonuses[i].y > canvas.height) shieldBonuses.splice(i, 1);
			}

			// satélites paralizadores fuera de pantalla 
			for (let i = satellites.length - 1; i >= 0; i--) {
				const s = satellites[i];
				if (s.x + s.size < 0 || s.x > canvas.width + s.size) {
					satellites.splice(i, 1);

					if (isInfiniteMode) { nextSatelliteSpawnTime = Date.now() + 3000; }
				}
			}

			// ondas de los satélites fuera de pantalla
			for (let i = waveSlices.length - 1; i >= 0; i--) {
				if (waveSlices[i].y - waveSlices.radius > canvas.height) waveSlices.splice(i, 1);
			}

			// Satélites cegadores fuera de pantalla
			for (let i = blindSatellites.length - 1; i >= 0; i--) {
				const s = blindSatellites[i];
				if (s.x + s.size < 0 || s.x > canvas.width + s.size) {
					blindSatellites.splice(i, 1);

					if (isInfiniteMode) { nextSatelliteSpawnTime = Date.now() + 3000; }
				}
			}

			// Ondas cegadoras fuera de pantalla
			for (let i = blindWaves.length - 1; i >= 0; i--) {
				const w = blindWaves[i];
				if (w.radius - w.thickness / 2 > w.maxDist) {
					blindWaves.splice(i, 1);
				}
			}

			// Satélites absorvedores fuera de pantalla
			for (let i = absorberSatellites.length - 1; i >= 0; i--) {
				const s = absorberSatellites[i];
				if (s.x + s.size < 0 || s.x > canvas.width + s.size) {
					absorberSatellites.splice(i, 1);

					if (isInfiniteMode) { nextSatelliteSpawnTime = Date.now() + 3000; }
				}
			}

			// Balas de la nave Espejo fuera de pantalla
			for (let i = mirrorBullets.length - 1; i >= 0; i--) {
				if (mirrorBullets[i].y > canvas.height + 10) mirrorBullets.splice(i, 1);
			}

		}

		function resetEntities() {
			bullets.length = 0;
			rocks.length = 0;
			bonuses.length = 0;
			powerUps.length = 0;
			explosions.length = 0;
			popups.length = 0;
			enemies.length = 0;
			enemyBullets.length = 0;
			shieldBonuses.length = 0;

			// Apagar rayos láser y reiniciar temporizadores
			laserShips.forEach(s => {
				s.laserOn = false;
				s.lastShot = Date.now();
				s.laserStart = 0;
				s.shieldHitTime = null;
			});
			laserShips.length = 0;
			fractalShips.length = 0;
			fractalBullets.length = 0;
			waveSlices.length = 0;
			satellites.length = 0;
			blindSatellites.length = 0;
			blindWaves.length = 0;
			absorberSatellites.length = 0;
			mirrorShip = null;
			mirrorDefeated = false;
			mirrorLastShot = 0;
			mirrorBullets.length = 0;
		}

		function resetBasicVariables() {
			lives = maxLives;
			score = 0;
			shotGrade = 0;
			quizCorrects = 0;
			quizFails = 0;
			startTime = Date.now();
			gameRunning = true;
			paused = false;
			levelActive = false;
			quizActive = false;
			player.shieldLevel = 0;
			player.lastHitTime = 0;
			player.flashTime = 0;
		}

		// Funciones de audio
		function playExplosionSound() {
			explosionSound.volume = 0.2; // entre 0 y 1
			explosionSound.currentTime = 0;
			explosionSound.play();
		}

		function playExplosionShipSound() {
			explosionShip.volume = 0.2; // entre 0 y 1
			explosionShip.currentTime = 0;
			explosionShip.play();
		}

		function playExplosionSatelliteSound() {
			explosionSatellite.volume = 0.2; // entre 0 y 1
			explosionSatellite.currentTime = 0;
			explosionSatellite.play();
		}

		// Función para refrescar el icono según el estado
		function updateMuteIcon() {
			muteIcon.textContent = muted ? "🔇" : "🔊";

			if (muted) {
				bgMusic.pause();
			} else {
				//bgMusic.currentTime = 0;
				bgMusic.play();
			}
		}

		function startBackgroundMusic() {
			if (!muted) {
				bgMusic.volume = 0.3;
				bgMusic.play();
			}
		}

		function loseLife() {
			if (currentLevel === 10 && extraLives > 0) {
				extraLives--;
			} else {
				if (!inmortal) {
					lives--;
				}
			}
			updateLivesDisplay();
		}

		function formatMMSS(totalSec) {
			const mm = String(Math.floor(totalSec / 60)).padStart(2, "0");
			const ss = String(totalSec % 60).padStart(2, "0");
			return `${mm}:${ss}`;
		}

		function captureLastRun() {
			const elapsedSec = Math.floor((Date.now() - startTime) / 1000);
			const answers = quizCorrects + quizFails;
			const correctPct = answers > 0 ? Math.round((quizCorrects / answers) * 100) : 0;
			const failPct = answers > 0 ? 100 - correctPct : 0;

			if (isInfiniteMode) {
				lastRunInfinite = {
					timeSec: elapsedSec,
					answers,
					corrects: quizCorrects,
					fails: quizFails,
					correctPct,
					failPct,
					score: score
				};
			} else {
				lastRun = {
					level: currentLevel + 1,
					timeSec: elapsedSec,
					answers,
					corrects: quizCorrects,
					fails: quizFails,
					correctPct,
					failPct
				};
			}
		}

		function updateAchievementsOverlay() {
			// Estadísticas de la última partida
			document.getElementById("achvLevel").textContent = lastRun.level;
			document.getElementById("achvTime").textContent = formatMMSS(lastRun.timeSec);
			document.getElementById("achvAnswers").textContent = lastRun.answers;
			document.getElementById("achvCorrects").textContent = `${lastRun.corrects} (${lastRun.correctPct}%)`;
			document.getElementById("achvFails").textContent = `${lastRun.fails} (${lastRun.failPct}%)`;

			// DEstadísticas del Mejor tiempo
			if (bestTimeRecord) {
				const s = bestTimeRecord.stats;
				document.getElementById("recBestTimeName").textContent = bestTimeRecord.name;
				document.getElementById("recBestTimeTime").innerHTML = `<strong>${formatMMSS(s.timeSec)}</strong>`;
				document.getElementById("recBestTimeQuestions").textContent = s.answers;
				document.getElementById("recBestTimeCorrects").textContent = `${s.corrects} (${s.correctPct}%)`;
				document.getElementById("recBestTimeFails").textContent = `${s.fails} (${s.failPct}%)`;
				document.getElementById("recBestTimeLevel").textContent = s.level;
			}

			// Estadísticas del que tiene Más aciertos
			if (bestCorrectsRecord) {
				const s = bestCorrectsRecord.stats;
				document.getElementById("recBestCorrName").textContent = bestCorrectsRecord.name;
				document.getElementById("recBestCorrTime").textContent = formatMMSS(s.timeSec);
				document.getElementById("recBestCorrQuestions").textContent = s.answers;
				document.getElementById("recBestCorrCorrects").innerHTML = `<strong>${s.corrects} (${s.correctPct}%)</strong>`;
				document.getElementById("recBestCorrFails").textContent = `${s.fails} (${s.failPct}%)`;
				document.getElementById("recBestCorrLevel").textContent = s.level;
			}
		}

		function updateAchievementsOverlayInfinite() {
			// Última partida (Infinito)
			document.getElementById("achvInfTime").textContent = formatMMSS(lastRunInfinite.timeSec);
			document.getElementById("achvInfAnswers").textContent = lastRunInfinite.answers;
			document.getElementById("achvInfCorrects").textContent = `${lastRunInfinite.corrects} (${lastRunInfinite.correctPct}%)`;
			document.getElementById("achvInfFails").textContent = `${lastRunInfinite.fails} (${lastRunInfinite.failPct}%)`;
			document.getElementById("achvInfScore").textContent = lastRunInfinite.score;

			// Récord: Mejor tiempo (Infinito) - Más tiempo es mejor
			if (bestTimeRecordInfinite) {
				const s = bestTimeRecordInfinite.stats;
				document.getElementById("recInfBestTimeName").textContent = bestTimeRecordInfinite.name;
				document.getElementById("recInfBestTimeTime").innerHTML = `<strong>${formatMMSS(s.timeSec)}</strong>`;
				document.getElementById("recInfBestTimeQuestions").textContent = s.answers;
				document.getElementById("recInfBestTimeCorrects").textContent = `${s.corrects} (${s.correctPct}%)`;
				document.getElementById("recInfBestTimeFails").textContent = `${s.fails} (${s.failPct}%)`;
				document.getElementById("recInfBestTimeScore").textContent = s.score;
			}

			// Récord: Más aciertos (Infinito)
			if (bestCorrectsRecordInfinite) {
				const s = bestCorrectsRecordInfinite.stats;
				document.getElementById("recInfBestCorrName").textContent = bestCorrectsRecordInfinite.name;
				document.getElementById("recInfBestCorrTime").textContent = formatMMSS(s.timeSec);
				document.getElementById("recInfBestCorrQuestions").textContent = s.answers;
				document.getElementById("recInfBestCorrCorrects").innerHTML = `<strong>${s.corrects} (${s.correctPct}%)</strong>`;
				document.getElementById("recInfBestCorrFails").textContent = `${s.fails} (${s.failPct}%)`;
				document.getElementById("recInfBestCorrScore").textContent = s.score;
			}

			// Récord: Mejor puntuación (Infinito)
			if (bestScoreRecordInfinite) {
				const s = bestScoreRecordInfinite.stats;
				document.getElementById("recInfBestScoreName").textContent = bestScoreRecordInfinite.name;
				document.getElementById("recInfBestScoreTime").textContent = formatMMSS(s.timeSec);
				document.getElementById("recInfBestScoreQuestions").textContent = s.answers;
				document.getElementById("recInfBestScoreCorrects").textContent = `${s.corrects} (${s.correctPct}%)`;
				document.getElementById("recInfBestScoreFails").textContent = `${s.fails} (${s.failPct}%)`;
				document.getElementById("recInfBestScoreScore").innerHTML = `<strong>${s.score}</strong>`;
			}
		}

		function actualizarMedallas() {
			for (const tipo in medallasEstado) {
				const imgElem = document.getElementById(`medalla-${tipo}`);
				//if (!imgElem) continue; 
				imgElem.src = imagePaths.medallas[tipo];
				if (!medallasEstado[tipo]) {
					imgElem.style.filter = "grayscale(100%)";
					imgElem.style.opacity = "0.6";
				} else {
					imgElem.style.filter = "none";
					imgElem.style.opacity = "1";
				}
			}
		}

		function checkAchivements() {
			if (quizCorrects >= 10 && !medallasEstado.aciertos_10) {
				medallasEstado.aciertos_10 = true;
			}

			if (quizCorrects >= 25 && quizFails == 0 && !medallasEstado.aciertos_25) {
				medallasEstado.aciertos_25 = true;
			}

			if (quizCorrects >= 50 && !medallasEstado.aciertos_50) {
				medallasEstado.aciertos_50 = true;
			}

			if (lastRun.timeSec < 600 && gameWon && !medallasEstado.veloz) {
				medallasEstado.veloz = true;
			}

			// Guardar en localStorage
			localStorage.setItem("medallasEstado", JSON.stringify(medallasEstado));
		}

		function checkRecords() {
			// --- Mejor tiempo (buscamos tiempo menor) ---
			if (gameWon) {
				if (!bestTimeRecord || lastRun.timeSec < bestTimeRecord.stats.timeSec) {
					const name = prompt("¡¡¡Nuevo récord de TIEMPO!!!: Escribe tu nombre!");
					bestTimeRecord = { name: name || "—", stats: { ...lastRun } };
					localStorage.setItem("bestTimeRecord", JSON.stringify(bestTimeRecord));
				}
			}

			// --- Más aciertos (si hat empate, se desempata por % aciertos) ---
			const currentCorrects = lastRun.corrects;
			const currentPct = lastRun.correctPct;
			if (!bestCorrectsRecord
				|| currentCorrects > bestCorrectsRecord.stats.corrects
				|| (currentCorrects === bestCorrectsRecord.stats.corrects
					&& currentPct > bestCorrectsRecord.stats.correctPct)) {
				const name = prompt("¡¡¡Nuevo récord de ACIERTOS!!!: Escribe tu nombre!");
				bestCorrectsRecord = { name: name || "—", stats: { ...lastRun } };
				localStorage.setItem("bestCorrectsRecord", JSON.stringify(bestCorrectsRecord));
			}
		}

		function checkInfiniteRecords() {
			// --- Mejor tiempo (sobrevivir más tiempo) ---
			if (!bestTimeRecordInfinite || lastRunInfinite.timeSec > bestTimeRecordInfinite.stats.timeSec) {
				const name = prompt("¡¡¡Nuevo récord de SUPERVIVENCIA!!!\nHas aguantado más tiempo que nadie.\n\nEscribe tu nombre:");
				bestTimeRecordInfinite = { name: name || "—", stats: { ...lastRunInfinite } };
				localStorage.setItem("bestTimeRecordInfinite", JSON.stringify(bestTimeRecordInfinite));
			}

			// --- Más aciertos ---
			const currentCorrects = lastRunInfinite.corrects;
			const currentPct = lastRunInfinite.correctPct;
			if (!bestCorrectsRecordInfinite
				|| currentCorrects > bestCorrectsRecordInfinite.stats.corrects
				|| (currentCorrects === bestCorrectsRecordInfinite.stats.corrects && currentPct > bestCorrectsRecordInfinite.stats.correctPct)) {
				const name = prompt("¡¡¡Nuevo récord de ACIERTOS (∞)!!!\nNadie ha acertado tanto en el modo infinito.\n\nEscribe tu nombre:");
				bestCorrectsRecordInfinite = { name: name || "—", stats: { ...lastRunInfinite } };
				localStorage.setItem("bestCorrectsRecordInfinite", JSON.stringify(bestCorrectsRecordInfinite));
			}

			// --- Mejor puntuación ---
			if (!bestScoreRecordInfinite || lastRunInfinite.score > bestScoreRecordInfinite.stats.score) {
				const name = prompt("¡¡¡Nuevo récord de PUNTUACIÓN (∞)!!!\nLa puntuación más alta hasta la fecha.\n\nEscribe tu nombre:");
				bestScoreRecordInfinite = { name: name || "—", stats: { ...lastRunInfinite } };
				localStorage.setItem("bestScoreRecordInfinite", JSON.stringify(bestScoreRecordInfinite));
			}
		}

		function spawnRandomInfiniteShip() {
			const shipTypes = ['basic', 'laser', 'fractal'];
			const randomType = shipTypes[Math.floor(Math.random() * shipTypes.length)];
			const side = Math.random() < 0.5 ? "left" : "right";

			switch (randomType) {
				case 'basic':
					spawnEnemy(side);
					break;
				case 'laser':
					spawnLaserShip(side);
					break;
				case 'fractal':
					spawnFractalShip(side);
					break;
			}
		}

		function spawnRandomInfiniteSatellite() {
			const satelliteTypes = ['satellite', 'blindSatellite', 'absorberSatellite'];
			const randomType = satelliteTypes[Math.floor(Math.random() * satelliteTypes.length)];

			switch (randomType) {
				case 'satellite':
					{
						const size = 30;
						const spawnSide = Math.random() < 0.5 ? "left" : "right";
						const x = spawnSide === "left" ? -size : canvas.width + size;
						const y = 100;
						const dx = spawnSide === "left" ? 1 : -1;
						satellites.push({
							x, y, size, dx, hp: 1,
							probShot: 0.02
						});
					}
					break;
				case 'blindSatellite':
					{
						const size = 30;
						const spawnSide = Math.random() < 0.5 ? "left" : "right";
						const x = spawnSide === "left" ? -size : canvas.width + size;
						const y = 100;
						const dx = spawnSide === "left" ? 1 : -1;
						let tmin = 4000;
						let tmax = 6000;
						blindSatellites.push({
							x, y, size, dx, hp: 1,
							nextWaveTime: Date.now() + tmin + Math.random() * (tmax - tmin)
						});
					}
					break;
				case 'absorberSatellite':
					{
						// Asegurarse de que no hay ya uno en pantalla
						if (absorberSatellites.length > 0) return;
						const size = 30;
						const spawnSide = Math.random() < 0.5 ? "left" : "right";
						const x = spawnSide === "left" ? -size : canvas.width + size;
						const y = 140;
						const dx = spawnSide === "left" ? 1 : -1;
						absorberSatellites.push({
							x, y, size, dx
						});
					}
					break;
			}
		}

		function refreshInfiniteButton() {
			const unlocked = localStorage.getItem("campaignCompleted") === "true";
			btnPlayInfinite.disabled = !unlocked;

			// Opcional: aspecto más claro cuando está bloqueado
			btnPlayInfinite.classList.toggle('bg-blue-700', unlocked);
			btnPlayInfinite.classList.toggle('hover:bg-blue-600', unlocked);
			btnPlayInfinite.classList.toggle('bg-gray-700', !unlocked);
			btnPlayInfinite.classList.toggle('hover:bg-gray-600', !unlocked);
			//btnPlayInfinite.textContent = unlocked ? 'Jugar ∞' : 'Bloqueado ∞';
		}

		function drawHealthBar(entity, color = "red") {
			const barX = entity.x + (entity.oscill ? Math.sin(entity.oscill) * 4 : 0);
			const barY = entity.y - 8;
			const barWidth = entity.width || entity.w;

			ctx.fillStyle = "#444";
			ctx.fillRect(barX, barY, barWidth, 6);
			const ratio = entity.hp / entity.hpIni;
			ctx.fillStyle = color;
			ctx.fillRect(barX, barY, barWidth * ratio, 6);
		}

		// ===== Game Loop =====
		function gameLoop() {
			if (!gameRunning) return;

			if (levelActive) {
				requestAnimationFrame(gameLoop);
				return;
			}
			if (quizActive) {
				requestAnimationFrame(gameLoop);
				return;
			}
			if (paused) {
				requestAnimationFrame(gameLoop);

				ctx.fillStyle = "rgba(0, 0, 0, 0.01)"; // fondo semitransparente
				ctx.fillRect(0, 0, canvas.width, canvas.height);

				ctx.fillStyle = "white";
				ctx.font = "bold 48px Arial";
				ctx.textAlign = "center";
				ctx.fillText("PAUSA", canvas.width / 2, canvas.height / 2);
				return;
			}

			//Comprobar si se ha perdido
			if (lives <= 0) { showGameOver(); return; }


			if (!isInfiniteMode) {	// Si es el modo de juego normal (modo campaña)
				if (score >= scoreGoal) {
					if (currentLevel < 10) {
						resetEntities();

						currentLevel++;
						score = 0;
						scoreGoal = levels[currentLevel].goal;
						updateHUD();
						showLevelOverlay();

						requestAnimationFrame(gameLoop);
						return;
					} else {
						gameWon = true
						showWin();
						return;
					}
				}
			} else {	// Si es el modo de juego infinito
				// Comprobar si hay naves enemigas activas
				const isShipActive = enemies.length > 0 || laserShips.length > 0 || fractalShips.length > 0;

				// Comprobar si hay satélites activos
				const isSatelliteActive = satellites.length > 0 || blindSatellites.length > 0 || absorberSatellites.length > 0;

				// Lógica de aparición de NAVES
				if (!isShipActive) {
					if (!nextShipSpawnTime) {
						// Si no hay naves, establece un retardo para la siguiente
						nextShipSpawnTime = Date.now() + 2000;
					}

					if (Date.now() >= nextShipSpawnTime) {
						spawnRandomInfiniteShip();
						nextShipSpawnTime = null; // Reinicia el temporizador
					}
				}

				// Lógica de aparición de SATÉLITES
				if (!isSatelliteActive) {
					if (!nextSatelliteSpawnTime) {
						// Si no hay satélites, establece un retardo para el siguiente
						nextSatelliteSpawnTime = Date.now() + 3000;
					}

					if (Date.now() >= nextSatelliteSpawnTime) {
						spawnRandomInfiniteSatellite();
						nextSatelliteSpawnTime = null; // Reinicia el temporizador
					}
				}
			}

			// LIMPIA (borra un área rectangular específica del lienzo, estableciendo 
			// los píxeles dentro de ese rectángulo a transparente negro (rgba(0, 0, 0, 0))
			// Todos los "draw" (dibujar elementos, deben hacerse después de esto o se borrarán)
			ctx.clearRect(0, 0, canvas.width, canvas.height);

			// Dibujar estrellas de fondo
			drawStars();

			// Movimiento y dibujo en pantalla de la nave del jugador
			movePlayer();
			drawPlayer();

			// Crear los bonus
			if (Math.random() < levels[currentLevel].rockRate) {
				spawnRock();
			}
			spawnBonus();
			spawnPowerUp();
			// Solo a partir del Nivel 4 (índice 3)
			if (currentLevel >= 3) {
				spawnShieldBonus();
			}

			// Dibujar entidades por pantalla (que hayan sido previamente creadas)
			drawRocks();			// Rocas (normales y fuertes)
			drawBullets();			// Balas del jugador
			drawBonuses();			// Bonus de disparo
			drawPowerUps();			// Bonus de vidas
			drawShieldBonuses();	// Bonus de escudo
			drawExplosions();		// Efecto de explosión (de las entidades que se hayan destruido)
			drawPopups();			// Efecto de mostrar cantidad de puntos obtenidos en la explosión

			if (isInfiniteMode) {	//Modo infinito
				// MODO INFINITO: Mueve y dibuja todos los tipos de enemigos posibles.

				// Cometas (ya que pueden aparecer)
				if (Math.random() < levels[currentLevel].cometRate) spawnComet();
				drawComets();

				// Naves enemigas básicas
				moveEnemies();
				updateEnemyShooting();
				drawEnemies();
				drawEnemyBullets();

				// Naves láser
				moveLaserShips();
				updateLaserFiring();
				drawLaserShips();
				drawLaserBeams();

				// Naves fractales
				moveFractalShips();
				updateFractalShooting();
				updateFractalBullets();
				drawFractalShips();
				drawFractalBullets();

				// Satélite paralizador
				moveSatellite();
				updateWaveShooting();
				drawSatellites();
				drawWaveSlices();

				// Satélite cegador
				moveBlindSatellites();
				updateBlindWave();
				drawBlindSatellites();
				drawBlindWaves();

				// Satélite absorbedor
				moveAbsorberSatellites();
				drawAbsorberSatellites();

			} else {	// Modo campaña
				// Nivel 4 (índice 3) → naves enemigas básicas
				if (currentLevel === 3) {
					moveEnemies();
					updateEnemyShooting();
					drawEnemies();
					drawEnemyBullets();
				}

				// Solo a partir del Nivel 5 (índice 4)
				if (currentLevel >= 4) {
					if (Math.random() < levels[currentLevel].cometRate) {
						spawnComet();
					}
					drawComets();
				}


				// Nivel 6 (índice 5) → naves láser
				if (currentLevel === 5) {
					moveLaserShips();
					updateLaserFiring();
					drawLaserShips();
					drawLaserBeams();
				}

				// Nivel 7 (índice 6) → nave fractal
				if (currentLevel === 6) {
					moveFractalShips();
					updateFractalShooting();
					updateFractalBullets();
					drawFractalShips();
					drawFractalBullets();
				}

				// Nivel 8 (índice 7) → satélite paralizador
				if (currentLevel === 7) {
					spawnSatellite();	// crea satélites
					moveSatellite();	// Mueve los satélites
					updateWaveShooting();	// Disparar ondas paralizadoras
					drawSatellites();	// Dibuja en pantalla los satélites paralizadores
					drawWaveSlices();	// Dibuja en pantalla las ondas de los satélites
				}

				// Nivel 9 (índice 8) → satélite cegador
				if (currentLevel === 8) {
					spawnBlindSatellite();
					moveBlindSatellites();
					updateBlindWave();
					drawBlindSatellites();	// Dibuja en pantalla los satélites cegadores
					drawBlindWaves();

					moveEnemies();
					updateEnemyShooting();
					drawEnemies();
					drawEnemyBullets();
				}

				if (currentLevel === 9) { // Nivel 10 (índice 9)
					spawnAbsorberSatellite();
					moveAbsorberSatellites();
					drawAbsorberSatellites();

					moveEnemies();
					updateEnemyShooting();
					drawEnemies();
					drawEnemyBullets();

					moveFractalShips();
					updateFractalShooting();
					updateFractalBullets();
					drawFractalShips();
					drawFractalBullets();
				}

				if (currentLevel === 10) {  // Nivel 11 - Final (índice 10)
					spawnMirrorShip();
					moveMirrorShip();
					drawMirrorShip();
					updateMirrorShooting();
					drawMirrorBullets();

					spawnAbsorberSatellite();
					moveAbsorberSatellites();
					drawAbsorberSatellites();
				}
			}

			// Comprueba si ciertas entidades (balas, rocas, enemigos...) han entrado en contacto.
			checkCollisions();

			// Elimina las entidades que han salido de la pantalla.
			cleanEntities()

			updateLivesDisplay();
			updateHUD();

			requestAnimationFrame(gameLoop);
		}

		// ===== Inicialización =====
		player.x = canvas.width / 2 - player.w / 2;
		player.y = canvas.height - player.h - 20;
		updateLivesDisplay();
		updateHUD();
		updateMuteIcon();// Inicializamos el icono al arrancar

		// Oculta Modo ∞ si el modo campaña no está completada
		//btnPlayInfinite = document.getElementById("btnPlayInfinite");
		// campaignDone = localStorage.getItem("campaignCompleted") === "true";
		// if (!campaignDone) {
		// 	btnPlayInfinite.disabled = true;	// impide el clic.
		// }
		refreshInfiniteButton();
		// Al cargar, mostramos primero el menú principal:
		showMainMenu();
	</script>
</body>

</html>